/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.6.1.0 (NJsonSchema v10.1.21.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

export class GetIPAddressInfoRequestDTOClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "https://bpaas-services-ledger.com/";
    }

    /**
     * Get misc. environment information.
     * @param accept Accept Header
     * @return Success
     */
    get(accept: Accept): Promise<GetIPAddressInfoResponseDTO> {
        let url_ = this.baseUrl + "/getipinfo/";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": accept !== undefined && accept !== null ? "" + accept : "",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<GetIPAddressInfoResponseDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = GetIPAddressInfoResponseDTO.fromJS(resultData200, _mappings);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GetIPAddressInfoResponseDTO>(<any>null);
    }
}

export class GrantBlockchainAccessDTOClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "https://bpaas-services-ledger.com/";
    }

    /**
     * grant a user access rights to a blokchain created by you
     * @param tenantID BPAAS Multi-Tennant ID
     * @param userID BPAAS UserID
     * @param requestingUserID BPAAS RequestingUserID
     * @param grantedUserID BPAAS GrantedUserID
     * @param dateTimeStamp (optional) BPAAS UpdatedByUserID
     * @param ledgerName BPAAS LedgerName
     * @param blockchainProofHash BPAAS hash of the proof proving that we have rights to the parent blockchain data we are attempting to update.
     * @param bPAASToken (optional) BPAAS security token to authenticate the user making the request.
     * @param bPAASRoles (optional) BPAAS roles of the user making the request.
     * @param body (optional)
     * @param accept Accept Header
     * @return Success
     */
    post(tenantID: string, userID: string, requestingUserID: string, grantedUserID: string[], dateTimeStamp: any | undefined, ledgerName: string, blockchainProofHash: string, bPAASToken: string | null | undefined, bPAASRoles: string | null | undefined, body: Blob | null | undefined, accept: Accept): Promise<GrantBlockchainAccessResponseDTO> {
        let url_ = this.baseUrl + "/grantblockchainaccess/";
        url_ = url_.replace(/[?&]$/, "");

        let content_ = "";
        if (tenantID === undefined || tenantID === null)
            throw new Error("The parameter 'tenantID' must be defined and cannot be null.");
        else
            content_ += encodeURIComponent("TenantID") + "=" + encodeURIComponent("" + tenantID) + "&";
        if (userID === undefined || userID === null)
            throw new Error("The parameter 'userID' must be defined and cannot be null.");
        else
            content_ += encodeURIComponent("UserID") + "=" + encodeURIComponent("" + userID) + "&";
        if (requestingUserID === undefined || requestingUserID === null)
            throw new Error("The parameter 'requestingUserID' must be defined and cannot be null.");
        else
            content_ += encodeURIComponent("RequestingUserID") + "=" + encodeURIComponent("" + requestingUserID) + "&";
        if (grantedUserID === undefined || grantedUserID === null)
            throw new Error("The parameter 'grantedUserID' must be defined and cannot be null.");
        else
            grantedUserID && grantedUserID.forEach(item => { content_ += encodeURIComponent("GrantedUserID") + "=" + encodeURIComponent("" + item) + "&"; });
        if (dateTimeStamp === null)
            throw new Error("The parameter 'dateTimeStamp' cannot be null.");
        else if (dateTimeStamp !== undefined)
            content_ += encodeURIComponent("DateTimeStamp") + "=" + encodeURIComponent(dateTimeStamp ? "" + dateTimeStamp.toJSON() : "") + "&";
        if (ledgerName === undefined || ledgerName === null)
            throw new Error("The parameter 'ledgerName' must be defined and cannot be null.");
        else
            content_ += encodeURIComponent("LedgerName") + "=" + encodeURIComponent("" + ledgerName) + "&";
        if (blockchainProofHash === undefined || blockchainProofHash === null)
            throw new Error("The parameter 'blockchainProofHash' must be defined and cannot be null.");
        else
            content_ += encodeURIComponent("BlockchainProofHash") + "=" + encodeURIComponent("" + blockchainProofHash) + "&";
        content_ = content_.replace(/&$/, "");

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "BPAASToken": bPAASToken !== undefined && bPAASToken !== null ? "" + bPAASToken : "",
                "BPAASRoles": bPAASRoles !== undefined && bPAASRoles !== null ? "" + bPAASRoles : "",
                "Accept": accept !== undefined && accept !== null ? "" + accept : "",
                "Content-Type": "application/x-www-form-urlencoded",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<GrantBlockchainAccessResponseDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = GrantBlockchainAccessResponseDTO.fromJS(resultData200, _mappings);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GrantBlockchainAccessResponseDTO>(<any>null);
    }
}

export class GetAuthorizedUsersDTOClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "https://bpaas-services-ledger.com/";
    }

    /**
     * get all authorized users for a specific ledger
     * @param tenantID BPAAS Multi-Tennant ID
     * @param userID BPAAS UserID
     * @param requestingUserID BPAAS RequestingUserID
     * @param ledgerName BPAAS LedgerName
     * @param blockchainProofHash BPAAS hash of the proof proving that we have rights to the parent blockchain data we are attempting to update.
     * @param bPAASToken (optional) BPAAS security token to authenticate the user making the request.
     * @param bPAASRoles (optional) BPAAS roles of the user making the request.
     * @param body (optional)
     * @param accept Accept Header
     * @return Success
     */
    post(tenantID: string, userID: string, requestingUserID: string, ledgerName: string, blockchainProofHash: string, bPAASToken: string | null | undefined, bPAASRoles: string | null | undefined, body: Blob | null | undefined, accept: Accept): Promise<GetAuthorizedUsersResponseDTOs> {
        let url_ = this.baseUrl + "/getauthorizedledgerusers/";
        url_ = url_.replace(/[?&]$/, "");

        let content_ = "";
        if (tenantID === undefined || tenantID === null)
            throw new Error("The parameter 'tenantID' must be defined and cannot be null.");
        else
            content_ += encodeURIComponent("TenantID") + "=" + encodeURIComponent("" + tenantID) + "&";
        if (userID === undefined || userID === null)
            throw new Error("The parameter 'userID' must be defined and cannot be null.");
        else
            content_ += encodeURIComponent("UserID") + "=" + encodeURIComponent("" + userID) + "&";
        if (requestingUserID === undefined || requestingUserID === null)
            throw new Error("The parameter 'requestingUserID' must be defined and cannot be null.");
        else
            content_ += encodeURIComponent("RequestingUserID") + "=" + encodeURIComponent("" + requestingUserID) + "&";
        if (ledgerName === undefined || ledgerName === null)
            throw new Error("The parameter 'ledgerName' must be defined and cannot be null.");
        else
            content_ += encodeURIComponent("LedgerName") + "=" + encodeURIComponent("" + ledgerName) + "&";
        if (blockchainProofHash === undefined || blockchainProofHash === null)
            throw new Error("The parameter 'blockchainProofHash' must be defined and cannot be null.");
        else
            content_ += encodeURIComponent("BlockchainProofHash") + "=" + encodeURIComponent("" + blockchainProofHash) + "&";
        content_ = content_.replace(/&$/, "");

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "BPAASToken": bPAASToken !== undefined && bPAASToken !== null ? "" + bPAASToken : "",
                "BPAASRoles": bPAASRoles !== undefined && bPAASRoles !== null ? "" + bPAASRoles : "",
                "Accept": accept !== undefined && accept !== null ? "" + accept : "",
                "Content-Type": "application/x-www-form-urlencoded",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<GetAuthorizedUsersResponseDTOs> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = GetAuthorizedUsersResponseDTOs.fromJS(resultData200, _mappings);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GetAuthorizedUsersResponseDTOs>(<any>null);
    }
}

export class RevokeBlockchainAccessDTOClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "https://bpaas-services-ledger.com/";
    }

    /**
     * revoke a user access rights to a blokchain created by you
     * @param tenantID BPAAS Multi-Tennant ID
     * @param userID BPAAS UserID
     * @param requestingUserID BPAAS RequestingUserID
     * @param revokedUserID BPAAS GrantedUserID
     * @param dateTimeStamp (optional) BPAAS UpdatedByUserID
     * @param ledgerName BPAAS LedgerName
     * @param blockchainProofHash BPAAS hash of the proof proving that we have rights to the parent blockchain data we are attempting to update.
     * @param bPAASToken (optional) BPAAS security token to authenticate the user making the request.
     * @param bPAASRoles (optional) BPAAS roles of the user making the request.
     * @param body (optional)
     * @param accept Accept Header
     * @return Success
     */
    post(tenantID: string, userID: string, requestingUserID: string, revokedUserID: string[], dateTimeStamp: any | undefined, ledgerName: string, blockchainProofHash: string, bPAASToken: string | null | undefined, bPAASRoles: string | null | undefined, body: Blob | null | undefined, accept: Accept): Promise<RevokeBlockchainAccessResponseDTOcs> {
        let url_ = this.baseUrl + "/revokeblockchainaccess/";
        url_ = url_.replace(/[?&]$/, "");

        let content_ = "";
        if (tenantID === undefined || tenantID === null)
            throw new Error("The parameter 'tenantID' must be defined and cannot be null.");
        else
            content_ += encodeURIComponent("TenantID") + "=" + encodeURIComponent("" + tenantID) + "&";
        if (userID === undefined || userID === null)
            throw new Error("The parameter 'userID' must be defined and cannot be null.");
        else
            content_ += encodeURIComponent("UserID") + "=" + encodeURIComponent("" + userID) + "&";
        if (requestingUserID === undefined || requestingUserID === null)
            throw new Error("The parameter 'requestingUserID' must be defined and cannot be null.");
        else
            content_ += encodeURIComponent("RequestingUserID") + "=" + encodeURIComponent("" + requestingUserID) + "&";
        if (revokedUserID === undefined || revokedUserID === null)
            throw new Error("The parameter 'revokedUserID' must be defined and cannot be null.");
        else
            revokedUserID && revokedUserID.forEach(item => { content_ += encodeURIComponent("RevokedUserID") + "=" + encodeURIComponent("" + item) + "&"; });
        if (dateTimeStamp === null)
            throw new Error("The parameter 'dateTimeStamp' cannot be null.");
        else if (dateTimeStamp !== undefined)
            content_ += encodeURIComponent("DateTimeStamp") + "=" + encodeURIComponent(dateTimeStamp ? "" + dateTimeStamp.toJSON() : "") + "&";
        if (ledgerName === undefined || ledgerName === null)
            throw new Error("The parameter 'ledgerName' must be defined and cannot be null.");
        else
            content_ += encodeURIComponent("LedgerName") + "=" + encodeURIComponent("" + ledgerName) + "&";
        if (blockchainProofHash === undefined || blockchainProofHash === null)
            throw new Error("The parameter 'blockchainProofHash' must be defined and cannot be null.");
        else
            content_ += encodeURIComponent("BlockchainProofHash") + "=" + encodeURIComponent("" + blockchainProofHash) + "&";
        content_ = content_.replace(/&$/, "");

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "BPAASToken": bPAASToken !== undefined && bPAASToken !== null ? "" + bPAASToken : "",
                "BPAASRoles": bPAASRoles !== undefined && bPAASRoles !== null ? "" + bPAASRoles : "",
                "Accept": accept !== undefined && accept !== null ? "" + accept : "",
                "Content-Type": "application/x-www-form-urlencoded",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<RevokeBlockchainAccessResponseDTOcs> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = RevokeBlockchainAccessResponseDTOcs.fromJS(resultData200, _mappings);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RevokeBlockchainAccessResponseDTOcs>(<any>null);
    }
}

export class CreateBlockchainLedgerDTOClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "https://bpaas-services-ledger.com/";
    }

    /**
     * create blockchain ledger
     * @param tenantID BPAAS Multi-Tennant ID
     * @param userID BPAAS UserID
     * @param requestingUserID BPAAS RequestingUserID
     * @param updatedByUserID BPAAS UpdatedByUserID
     * @param dateTimeStamp (optional) BPAAS UpdatedByUserID
     * @param ledgerName BPAAS LedgerName
     * @param ledgerDescription BPAAS Ledger Description
     * @param isLocked (optional) BPAAS flag signifying if a blockchain is public or private.  If private only specific users can modify the blockchain.
     * @param assignedRoles BPAAS assigned roles of the ledger.
     * @param bPAASToken (optional) BPAAS security token to authenticate the user making the request.
     * @param bPAASRoles (optional) BPAAS roles of the user making the request.
     * @param body (optional)
     * @param accept Accept Header
     * @return Success
     */
    post(tenantID: string, userID: string, requestingUserID: string, updatedByUserID: string, dateTimeStamp: any | undefined, ledgerName: string, ledgerDescription: string, isLocked: any | undefined, assignedRoles: string, bPAASToken: string | null | undefined, bPAASRoles: string | null | undefined, body: Blob | null | undefined, accept: Accept): Promise<CreateBlockchainLedgerResponseDTO> {
        let url_ = this.baseUrl + "/createblockchainledger/";
        url_ = url_.replace(/[?&]$/, "");

        let content_ = "";
        if (tenantID === undefined || tenantID === null)
            throw new Error("The parameter 'tenantID' must be defined and cannot be null.");
        else
            content_ += encodeURIComponent("TenantID") + "=" + encodeURIComponent("" + tenantID) + "&";
        if (userID === undefined || userID === null)
            throw new Error("The parameter 'userID' must be defined and cannot be null.");
        else
            content_ += encodeURIComponent("UserID") + "=" + encodeURIComponent("" + userID) + "&";
        if (requestingUserID === undefined || requestingUserID === null)
            throw new Error("The parameter 'requestingUserID' must be defined and cannot be null.");
        else
            content_ += encodeURIComponent("RequestingUserID") + "=" + encodeURIComponent("" + requestingUserID) + "&";
        if (updatedByUserID === undefined || updatedByUserID === null)
            throw new Error("The parameter 'updatedByUserID' must be defined and cannot be null.");
        else
            content_ += encodeURIComponent("UpdatedByUserID") + "=" + encodeURIComponent("" + updatedByUserID) + "&";
        if (dateTimeStamp === null)
            throw new Error("The parameter 'dateTimeStamp' cannot be null.");
        else if (dateTimeStamp !== undefined)
            content_ += encodeURIComponent("DateTimeStamp") + "=" + encodeURIComponent(dateTimeStamp ? "" + dateTimeStamp.toJSON() : "") + "&";
        if (ledgerName === undefined || ledgerName === null)
            throw new Error("The parameter 'ledgerName' must be defined and cannot be null.");
        else
            content_ += encodeURIComponent("LedgerName") + "=" + encodeURIComponent("" + ledgerName) + "&";
        if (ledgerDescription === undefined || ledgerDescription === null)
            throw new Error("The parameter 'ledgerDescription' must be defined and cannot be null.");
        else
            content_ += encodeURIComponent("LedgerDescription") + "=" + encodeURIComponent("" + ledgerDescription) + "&";
        content_ = content_.replace(/&$/, "");

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "IsLocked": isLocked !== undefined && isLocked !== null ? "" + isLocked : "",
                "AssignedRoles": assignedRoles !== undefined && assignedRoles !== null ? "" + assignedRoles : "",
                "BPAASToken": bPAASToken !== undefined && bPAASToken !== null ? "" + bPAASToken : "",
                "BPAASRoles": bPAASRoles !== undefined && bPAASRoles !== null ? "" + bPAASRoles : "",
                "Accept": accept !== undefined && accept !== null ? "" + accept : "",
                "Content-Type": "application/x-www-form-urlencoded",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<CreateBlockchainLedgerResponseDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = CreateBlockchainLedgerResponseDTO.fromJS(resultData200, _mappings);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CreateBlockchainLedgerResponseDTO>(<any>null);
    }
}

export class AddToBlockchainLedgerDTOClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:8080/api";
    }

    /**
     * add block to blockchain ledger
     * @param tenantID BPAAS Multi-Tennant ID
     * @param userID BPAAS UserID
     * @param requestingUserID BPAAS RequestingUserID
     * @param updatedByUserID BPAAS UpdatedByUserID
     * @param dateTimeStamp (optional) BPAAS UpdatedByUserID
     * @param ledgerName BPAAS LedgerName
     * @param isFile (optional) BPAAS IsFile
     * @param fileExtension (optional) BPAAS FileExtension
     * @param saveTextAsFile (optional) BPAAS SaveTextAsFile
     * @param isSmartContract (optional) BPAAS is this a smart contract block document.
     * @param blockName BPAAS Block name
     * @param blockDescription (optional) BPAAS Description of the block.
     * @param blockProofHash (optional) BPAAS hash of the proof proving that we have rights to the block data we are attempting to update.
     * @param blockchainProofHash BPAAS hash of the proof proving that we have rights to the parent blockchain data we are attempting to update.
     * @param isActive (optional) BPAAS flag signifying if a block is active or not.
     * @param bPAASToken (optional) BPAAS security token to authenticate the user making the request.
     * @param bPAASRoles (optional) BPAAS roles of the user making the request.
     * @param body (optional)
     * @param accept Accept Header
     * @return Success
     */
    post(tenantID: string, userID: string, requestingUserID: string, updatedByUserID: string, dateTimeStamp: any | undefined, ledgerName: string, isFile: any | undefined, fileExtension: string | null | undefined, saveTextAsFile: any | undefined, isSmartContract: any | undefined, blockName: string, blockDescription: string | null | undefined, blockProofHash: string | null | undefined, blockchainProofHash: string, isActive: any | undefined, bPAASToken: string | null | undefined, bPAASRoles: string | null | undefined, body: any | null | undefined, accept: Accept): Promise<AddToBlockchainLedgerResponseDTO> {
        let url_ = this.baseUrl + "/addblock/";


        url_ = url_.replace(/[?&]$/, "");

        console.log(url_);


        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "TenantID": tenantID !== undefined && tenantID !== null ? "" + tenantID : "",
                "UserID": userID !== undefined && userID !== null ? "" + userID : "",
                "RequestingUserID": requestingUserID !== undefined && requestingUserID !== null ? "" + requestingUserID : "",
                "UpdatedByUserID": updatedByUserID !== undefined && updatedByUserID !== null ? "" + updatedByUserID : "",
                "DateTimeStamp": dateTimeStamp !== undefined && dateTimeStamp !== null ? "" + dateTimeStamp : "",
                "LedgerName": ledgerName !== undefined && ledgerName !== null ? "" + ledgerName : "",
                "IsFile": isFile !== undefined && isFile !== null ? "" + isFile : "",
                "FileExtension": fileExtension !== undefined && fileExtension !== null ? "" + fileExtension : "",
                "SaveTextAsFile": saveTextAsFile !== undefined && saveTextAsFile !== null ? "" + saveTextAsFile : "",
                "IsSmartContract": isSmartContract !== undefined && isSmartContract !== null ? "" + isSmartContract : "",
                "BlockName": blockName !== undefined && blockName !== null ? "" + blockName : "",
                "BlockDescription": blockDescription !== undefined && blockDescription !== null ? "" + blockDescription : "",
                "BlockProofHash": blockProofHash !== undefined && blockProofHash !== null ? "" + blockProofHash : "",
                "BlockchainProofHash": blockchainProofHash !== undefined && blockchainProofHash !== null ? "" + blockchainProofHash : "",
                "IsActive": isActive !== undefined && isActive !== null ? "" + isActive : "",
                "BPAASToken": bPAASToken !== undefined && bPAASToken !== null ? "" + bPAASToken : "",
                "BPAASRoles": bPAASRoles !== undefined && bPAASRoles !== null ? "" + bPAASRoles : "",
                "Accept": accept !== undefined && accept !== null ? "" + accept : "",
                "Content-Type": "application/json",
                "Access-Control-Allow-Origin": "*"
            }
        };

        console.log(options_);

        return this.http.fetch(url_, options_).then((_response: Response) => {
            console.log(_response);
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<AddToBlockchainLedgerResponseDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = AddToBlockchainLedgerResponseDTO.fromJS(resultData200, _mappings);
            result200.isSuccess = true;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {

          let message = "An unexpected server error occurred.";
            return response.text().then((_responseText) => {
              message = _responseText;
              //throw new Error(message);
              let error = new AddToBlockchainLedgerResponseDTO();
              error.isSuccess = false;
              error.errorMessage = message;
              return error;

            //return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });


        }
        return Promise.resolve<AddToBlockchainLedgerResponseDTO>(<any>null);
    }
}

export class DeleteFromBlockchainLedgerDTOClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "https://bpaas-services-ledger.com/";
    }

    /**
     * delete block from blockchain ledger
     * @param tenantID BPAAS Multi-Tennant ID
     * @param userID BPAAS UserID
     * @param requestingUserID BPAAS RequestingUserID
     * @param updatedByUserID BPAAS UpdatedByUserID
     * @param ledgerName BPAAS LedgerName
     * @param dateTimeStamp (optional) BPAAS UpdatedByUserID
     * @param blockName BPAAS Block name
     * @param blockProofHash BPAAS hash of the proof proving that we have rights to the block data we are attempting to update.
     * @param blockchainProofHash BPAAS hash of the proof proving that we have rights to the parent blockchain data we are attempting to update.
     * @param bPAASToken (optional) BPAAS security token to authenticate the user making the request.
     * @param bPAASRoles (optional) BPAAS roles of the user making the request.
     * @param body (optional)
     * @param accept Accept Header
     * @return Success
     */
    post(tenantID: string, userID: string, requestingUserID: string, updatedByUserID: string, ledgerName: string, dateTimeStamp: any | undefined, blockName: string, blockProofHash: string, blockchainProofHash: string, bPAASToken: string | null | undefined, bPAASRoles: string | null | undefined, body: Blob | null | undefined, accept: Accept): Promise<DeleteFromBlockchainLedgerResponseDTO> {
        let url_ = this.baseUrl + "/deleteblock/";
        url_ = url_.replace(/[?&]$/, "");

        let content_ = "";
        if (tenantID === undefined || tenantID === null)
            throw new Error("The parameter 'tenantID' must be defined and cannot be null.");
        else
            content_ += encodeURIComponent("TenantID") + "=" + encodeURIComponent("" + tenantID) + "&";
        if (userID === undefined || userID === null)
            throw new Error("The parameter 'userID' must be defined and cannot be null.");
        else
            content_ += encodeURIComponent("UserID") + "=" + encodeURIComponent("" + userID) + "&";
        if (requestingUserID === undefined || requestingUserID === null)
            throw new Error("The parameter 'requestingUserID' must be defined and cannot be null.");
        else
            content_ += encodeURIComponent("RequestingUserID") + "=" + encodeURIComponent("" + requestingUserID) + "&";
        if (updatedByUserID === undefined || updatedByUserID === null)
            throw new Error("The parameter 'updatedByUserID' must be defined and cannot be null.");
        else
            content_ += encodeURIComponent("UpdatedByUserID") + "=" + encodeURIComponent("" + updatedByUserID) + "&";
        if (ledgerName === undefined || ledgerName === null)
            throw new Error("The parameter 'ledgerName' must be defined and cannot be null.");
        else
            content_ += encodeURIComponent("LedgerName") + "=" + encodeURIComponent("" + ledgerName) + "&";
        if (dateTimeStamp === null)
            throw new Error("The parameter 'dateTimeStamp' cannot be null.");
        else if (dateTimeStamp !== undefined)
            content_ += encodeURIComponent("DateTimeStamp") + "=" + encodeURIComponent(dateTimeStamp ? "" + dateTimeStamp.toJSON() : "") + "&";
        if (blockName === undefined || blockName === null)
            throw new Error("The parameter 'blockName' must be defined and cannot be null.");
        else
            content_ += encodeURIComponent("BlockName") + "=" + encodeURIComponent("" + blockName) + "&";
        if (blockProofHash === undefined || blockProofHash === null)
            throw new Error("The parameter 'blockProofHash' must be defined and cannot be null.");
        else
            content_ += encodeURIComponent("BlockProofHash") + "=" + encodeURIComponent("" + blockProofHash) + "&";
        if (blockchainProofHash === undefined || blockchainProofHash === null)
            throw new Error("The parameter 'blockchainProofHash' must be defined and cannot be null.");
        else
            content_ += encodeURIComponent("BlockchainProofHash") + "=" + encodeURIComponent("" + blockchainProofHash) + "&";
        content_ = content_.replace(/&$/, "");

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "BPAASToken": bPAASToken !== undefined && bPAASToken !== null ? "" + bPAASToken : "",
                "BPAASRoles": bPAASRoles !== undefined && bPAASRoles !== null ? "" + bPAASRoles : "",
                "Accept": accept !== undefined && accept !== null ? "" + accept : "",
                "Content-Type": "application/x-www-form-urlencoded",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<DeleteFromBlockchainLedgerResponseDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = DeleteFromBlockchainLedgerResponseDTO.fromJS(resultData200, _mappings);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DeleteFromBlockchainLedgerResponseDTO>(<any>null);
    }
}

export class LockBlockchainLedgerDTOClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "https://bpaas-services-ledger.com/";
    }

    /**
     * lock blockchain ledger
     * @param tenantID BPAAS Multi-Tennant ID
     * @param userID BPAAS UserID
     * @param requestingUserID BPAAS RequestingUserID
     * @param dateTimeStamp (optional) BPAAS UpdatedByUserID
     * @param ledgerName BPAAS LedgerName
     * @param isPublic (optional) BPAAS flag signifying if a blockchain is public or private.  If private only specific users can modify the blockchain.
     * @param blockchainProofHash BPAAS hash of the proof proving that we have rights to the parent blockchain data we are attempting to update.
     * @param bPAASToken (optional) BPAAS security token to authenticate the user making the request.
     * @param bPAASRoles (optional) BPAAS roles of the user making the request.
     * @param body (optional)
     * @param accept Accept Header
     * @return Success
     */
    post(tenantID: string, userID: string, requestingUserID: string, dateTimeStamp: any | undefined, ledgerName: string, isPublic: any | undefined, blockchainProofHash: string, bPAASToken: string | null | undefined, bPAASRoles: string | null | undefined, body: Blob | null | undefined, accept: Accept): Promise<LockBlockchainLedgerResponseDTO> {
        let url_ = this.baseUrl + "/lockblockchainledger/";
        url_ = url_.replace(/[?&]$/, "");

        let content_ = "";
        if (tenantID === undefined || tenantID === null)
            throw new Error("The parameter 'tenantID' must be defined and cannot be null.");
        else
            content_ += encodeURIComponent("TenantID") + "=" + encodeURIComponent("" + tenantID) + "&";
        if (userID === undefined || userID === null)
            throw new Error("The parameter 'userID' must be defined and cannot be null.");
        else
            content_ += encodeURIComponent("UserID") + "=" + encodeURIComponent("" + userID) + "&";
        if (requestingUserID === undefined || requestingUserID === null)
            throw new Error("The parameter 'requestingUserID' must be defined and cannot be null.");
        else
            content_ += encodeURIComponent("RequestingUserID") + "=" + encodeURIComponent("" + requestingUserID) + "&";
        if (dateTimeStamp === null)
            throw new Error("The parameter 'dateTimeStamp' cannot be null.");
        else if (dateTimeStamp !== undefined)
            content_ += encodeURIComponent("DateTimeStamp") + "=" + encodeURIComponent(dateTimeStamp ? "" + dateTimeStamp.toJSON() : "") + "&";
        if (ledgerName === undefined || ledgerName === null)
            throw new Error("The parameter 'ledgerName' must be defined and cannot be null.");
        else
            content_ += encodeURIComponent("LedgerName") + "=" + encodeURIComponent("" + ledgerName) + "&";
        content_ = content_.replace(/&$/, "");

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "IsPublic": isPublic !== undefined && isPublic !== null ? "" + isPublic : "",
                "BlockchainProofHash": blockchainProofHash !== undefined && blockchainProofHash !== null ? "" + blockchainProofHash : "",
                "BPAASToken": bPAASToken !== undefined && bPAASToken !== null ? "" + bPAASToken : "",
                "BPAASRoles": bPAASRoles !== undefined && bPAASRoles !== null ? "" + bPAASRoles : "",
                "Accept": accept !== undefined && accept !== null ? "" + accept : "",
                "Content-Type": "application/x-www-form-urlencoded",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<LockBlockchainLedgerResponseDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = LockBlockchainLedgerResponseDTO.fromJS(resultData200, _mappings);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LockBlockchainLedgerResponseDTO>(<any>null);
    }
}

export class UnLockBlockchainLedgerDTOClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "https://bpaas-services-ledger.com/";
    }

    /**
     * unlock blockchain ledger
     * @param tenantID BPAAS Multi-Tennant ID
     * @param userID BPAAS UserID
     * @param requestingUserID BPAAS RequestingUserID
     * @param dateTimeStamp (optional) BPAAS UpdatedByUserID
     * @param ledgerName BPAAS LedgerName
     * @param isPublic (optional) BPAAS flag signifying if a blockchain is public or private.  If private only specific users can modify the blockchain.
     * @param blockchainProofHash BPAAS hash of the proof proving that we have rights to the parent blockchain data we are attempting to update.
     * @param bPAASToken (optional) BPAAS security token to authenticate the user making the request.
     * @param bPAASRoles (optional) BPAAS roles of the user making the request.
     * @param body (optional)
     * @param accept Accept Header
     * @return Success
     */
    post(tenantID: string, userID: string, requestingUserID: string, dateTimeStamp: any | undefined, ledgerName: string, isPublic: any | undefined, blockchainProofHash: string, bPAASToken: string | null | undefined, bPAASRoles: string | null | undefined, body: Blob | null | undefined, accept: Accept): Promise<UnLockBlockchainLedgerResponseDTO> {
        let url_ = this.baseUrl + "/unlockblockchainledger/";
        url_ = url_.replace(/[?&]$/, "");

        let content_ = "";
        if (tenantID === undefined || tenantID === null)
            throw new Error("The parameter 'tenantID' must be defined and cannot be null.");
        else
            content_ += encodeURIComponent("TenantID") + "=" + encodeURIComponent("" + tenantID) + "&";
        if (userID === undefined || userID === null)
            throw new Error("The parameter 'userID' must be defined and cannot be null.");
        else
            content_ += encodeURIComponent("UserID") + "=" + encodeURIComponent("" + userID) + "&";
        if (requestingUserID === undefined || requestingUserID === null)
            throw new Error("The parameter 'requestingUserID' must be defined and cannot be null.");
        else
            content_ += encodeURIComponent("RequestingUserID") + "=" + encodeURIComponent("" + requestingUserID) + "&";
        if (dateTimeStamp === null)
            throw new Error("The parameter 'dateTimeStamp' cannot be null.");
        else if (dateTimeStamp !== undefined)
            content_ += encodeURIComponent("DateTimeStamp") + "=" + encodeURIComponent(dateTimeStamp ? "" + dateTimeStamp.toJSON() : "") + "&";
        if (ledgerName === undefined || ledgerName === null)
            throw new Error("The parameter 'ledgerName' must be defined and cannot be null.");
        else
            content_ += encodeURIComponent("LedgerName") + "=" + encodeURIComponent("" + ledgerName) + "&";
        content_ = content_.replace(/&$/, "");

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "IsPublic": isPublic !== undefined && isPublic !== null ? "" + isPublic : "",
                "BlockchainProofHash": blockchainProofHash !== undefined && blockchainProofHash !== null ? "" + blockchainProofHash : "",
                "BPAASToken": bPAASToken !== undefined && bPAASToken !== null ? "" + bPAASToken : "",
                "BPAASRoles": bPAASRoles !== undefined && bPAASRoles !== null ? "" + bPAASRoles : "",
                "Accept": accept !== undefined && accept !== null ? "" + accept : "",
                "Content-Type": "application/x-www-form-urlencoded",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<UnLockBlockchainLedgerResponseDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = UnLockBlockchainLedgerResponseDTO.fromJS(resultData200, _mappings);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UnLockBlockchainLedgerResponseDTO>(<any>null);
    }
}

export class GetAllBlockchainsByTenantIDDTOClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "https://bpaas-services-ledger.com/";
    }

    /**
     * return blockchains by tenant ID within the blockchain ledger
     * @param tenantID BPAAS Multi-Tennant ID
     * @param userID BPAAS Multi-Tennant UserID
     * @param bPAASToken (optional) BPAAS security token to authenticate the user making the request.
     * @param bPAASRoles (optional) BPAAS roles of the user making the request.
     * @param body (optional)
     * @param accept Accept Header
     * @return Success
     */
    post(tenantID: string, userID: string, bPAASToken: string | null | undefined, bPAASRoles: string | null | undefined, body: Blob | null | undefined, accept: Accept): Promise<CreateBlockchainLedgerResponseDTO[]> {
        let url_ = this.baseUrl + "/getAllBlockchainsByTenantID/";
        url_ = url_.replace(/[?&]$/, "");

        let content_ = "";
        if (tenantID === undefined || tenantID === null)
            throw new Error("The parameter 'tenantID' must be defined and cannot be null.");
        else
            content_ += encodeURIComponent("TenantID") + "=" + encodeURIComponent("" + tenantID) + "&";
        if (userID === undefined || userID === null)
            throw new Error("The parameter 'userID' must be defined and cannot be null.");
        else
            content_ += encodeURIComponent("UserID") + "=" + encodeURIComponent("" + userID) + "&";
        content_ = content_.replace(/&$/, "");

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "BPAASToken": bPAASToken !== undefined && bPAASToken !== null ? "" + bPAASToken : "",
                "BPAASRoles": bPAASRoles !== undefined && bPAASRoles !== null ? "" + bPAASRoles : "",
                "Accept": accept !== undefined && accept !== null ? "" + accept : "",
                "Content-Type": "application/x-www-form-urlencoded",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<CreateBlockchainLedgerResponseDTO[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CreateBlockchainLedgerResponseDTO.fromJS(item, _mappings));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CreateBlockchainLedgerResponseDTO[]>(<any>null);
    }
}

export class GetAllBlockByBlockchainLedgerIDDTOClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "https://bpaas-services-ledger.com/";
    }

    /**
     * return blocks in a blockchain ledger
     * @param tenantID BPAAS Multi-Tennant ID
     * @param userID BPAAS UserID
     * @param requestingUserID BPAAS RequestingUserID
     * @param ledgerName BPAAS LedgerName
     * @param blockchainProofHash BPAAS hash of the proof proving that we have rights to the parent blockchain data we are attempting to update.
     * @param bPAASToken (optional) BPAAS security token to authenticate the user making the request.
     * @param bPAASRoles (optional) BPAAS roles of the user making the request.
     * @param body (optional)
     * @param accept Accept Header
     * @return Success
     */
    post(tenantID: string, userID: string, requestingUserID: string, ledgerName: string, blockchainProofHash: string, bPAASToken: string | null | undefined, bPAASRoles: string | null | undefined, body: Blob | null | undefined, accept: Accept): Promise<AddToBlockchainLedgerResponseDTO> {
        let url_ = this.baseUrl + "/getAllBlockByBlockchainLedgerID/";
        url_ = url_.replace(/[?&]$/, "");

        let content_ = "";
        if (tenantID === undefined || tenantID === null)
            throw new Error("The parameter 'tenantID' must be defined and cannot be null.");
        else
            content_ += encodeURIComponent("TenantID") + "=" + encodeURIComponent("" + tenantID) + "&";
        if (userID === undefined || userID === null)
            throw new Error("The parameter 'userID' must be defined and cannot be null.");
        else
            content_ += encodeURIComponent("UserID") + "=" + encodeURIComponent("" + userID) + "&";
        if (requestingUserID === undefined || requestingUserID === null)
            throw new Error("The parameter 'requestingUserID' must be defined and cannot be null.");
        else
            content_ += encodeURIComponent("RequestingUserID") + "=" + encodeURIComponent("" + requestingUserID) + "&";
        if (ledgerName === undefined || ledgerName === null)
            throw new Error("The parameter 'ledgerName' must be defined and cannot be null.");
        else
            content_ += encodeURIComponent("LedgerName") + "=" + encodeURIComponent("" + ledgerName) + "&";
        content_ = content_.replace(/&$/, "");

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "BlockchainProofHash": blockchainProofHash !== undefined && blockchainProofHash !== null ? "" + blockchainProofHash : "",
                "BPAASToken": bPAASToken !== undefined && bPAASToken !== null ? "" + bPAASToken : "",
                "BPAASRoles": bPAASRoles !== undefined && bPAASRoles !== null ? "" + bPAASRoles : "",
                "Accept": accept !== undefined && accept !== null ? "" + accept : "",
                "Content-Type": "application/x-www-form-urlencoded",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<AddToBlockchainLedgerResponseDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = AddToBlockchainLedgerResponseDTO.fromJS(resultData200, _mappings);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AddToBlockchainLedgerResponseDTO>(<any>null);
    }
}

export class GetTransactionStatsByTenantIDDTOClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "https://bpaas-services-ledger.com/";
    }

    /**
     * get tenant transactions
     * @param tenantID BPAAS Multi-Tennant ID
     * @param userID BPAAS UserID
     * @param requestingUserID BPAAS RequestingUserID
     * @param startDate BPAAS Transaction StartDate
     * @param endDate BPAAS Transaction EndDate
     * @param bPAASToken (optional) BPAAS security token to authenticate the user making the request.
     * @param bPAASRoles (optional) BPAAS roles of the user making the request.
     * @param body (optional)
     * @param accept Accept Header
     * @return Success
     */
    post(tenantID: string, userID: string, requestingUserID: string, startDate: any, endDate: any, bPAASToken: string | null | undefined, bPAASRoles: string | null | undefined, body: Blob | null | undefined, accept: Accept): Promise<GetTransactionStatsByTenantIDResponseDTO> {
        let url_ = this.baseUrl + "/gettransactionsbytenant/";
        url_ = url_.replace(/[?&]$/, "");

        let content_ = "";
        if (tenantID === undefined || tenantID === null)
            throw new Error("The parameter 'tenantID' must be defined and cannot be null.");
        else
            content_ += encodeURIComponent("TenantID") + "=" + encodeURIComponent("" + tenantID) + "&";
        if (userID === undefined || userID === null)
            throw new Error("The parameter 'userID' must be defined and cannot be null.");
        else
            content_ += encodeURIComponent("UserID") + "=" + encodeURIComponent("" + userID) + "&";
        if (requestingUserID === undefined || requestingUserID === null)
            throw new Error("The parameter 'requestingUserID' must be defined and cannot be null.");
        else
            content_ += encodeURIComponent("RequestingUserID") + "=" + encodeURIComponent("" + requestingUserID) + "&";
        if (startDate === undefined || startDate === null)
            throw new Error("The parameter 'startDate' must be defined and cannot be null.");
        else
            content_ += encodeURIComponent("StartDate") + "=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&";
        if (endDate === undefined || endDate === null)
            throw new Error("The parameter 'endDate' must be defined and cannot be null.");
        else
            content_ += encodeURIComponent("EndDate") + "=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&";
        content_ = content_.replace(/&$/, "");

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "BPAASToken": bPAASToken !== undefined && bPAASToken !== null ? "" + bPAASToken : "",
                "BPAASRoles": bPAASRoles !== undefined && bPAASRoles !== null ? "" + bPAASRoles : "",
                "Accept": accept !== undefined && accept !== null ? "" + accept : "",
                "Content-Type": "application/x-www-form-urlencoded",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<GetTransactionStatsByTenantIDResponseDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = GetTransactionStatsByTenantIDResponseDTO.fromJS(resultData200, _mappings);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GetTransactionStatsByTenantIDResponseDTO>(<any>null);
    }
}

export class DownloadBlockDataDTOClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "https://bpaas-services-ledger.com/";
    }

    /**
     * download block from blockchain ledger
     * @param tenantID BPAAS Multi-Tennant ID
     * @param userID BPAAS UserID
     * @param requestingUserID BPAAS RequestingUserID
     * @param ledgerName BPAAS LedgerName
     * @param blockName BPAAS Block name
     * @param blockProofHash BPAAS hash of the proof proving that we have rights to the block data we are attempting to update.
     * @param blockchainProofHash BPAAS hash of the proof proving that we have rights to the parent blockchain data we are attempting to update.
     * @param bPAASToken (optional) BPAAS security token to authenticate the user making the request.
     * @param bPAASRoles (optional) BPAAS roles of the user making the request.
     * @param body (optional)
     * @param accept Accept Header
     * @return Success
     */
    post(tenantID: string, userID: string, requestingUserID: string, ledgerName: string, blockName: string, blockProofHash: string, blockchainProofHash: string, bPAASToken: string | null | undefined, bPAASRoles: string | null | undefined, body: Blob | null | undefined, accept: Accept): Promise<Stream> {
        let url_ = this.baseUrl + "/downloadblock/";
        url_ = url_.replace(/[?&]$/, "");

        let content_ = "";
        if (tenantID === undefined || tenantID === null)
            throw new Error("The parameter 'tenantID' must be defined and cannot be null.");
        else
            content_ += encodeURIComponent("TenantID") + "=" + encodeURIComponent("" + tenantID) + "&";
        if (userID === undefined || userID === null)
            throw new Error("The parameter 'userID' must be defined and cannot be null.");
        else
            content_ += encodeURIComponent("UserID") + "=" + encodeURIComponent("" + userID) + "&";
        if (requestingUserID === undefined || requestingUserID === null)
            throw new Error("The parameter 'requestingUserID' must be defined and cannot be null.");
        else
            content_ += encodeURIComponent("RequestingUserID") + "=" + encodeURIComponent("" + requestingUserID) + "&";
        if (ledgerName === undefined || ledgerName === null)
            throw new Error("The parameter 'ledgerName' must be defined and cannot be null.");
        else
            content_ += encodeURIComponent("LedgerName") + "=" + encodeURIComponent("" + ledgerName) + "&";
        if (blockName === undefined || blockName === null)
            throw new Error("The parameter 'blockName' must be defined and cannot be null.");
        else
            content_ += encodeURIComponent("BlockName") + "=" + encodeURIComponent("" + blockName) + "&";
        if (blockProofHash === undefined || blockProofHash === null)
            throw new Error("The parameter 'blockProofHash' must be defined and cannot be null.");
        else
            content_ += encodeURIComponent("BlockProofHash") + "=" + encodeURIComponent("" + blockProofHash) + "&";
        if (blockchainProofHash === undefined || blockchainProofHash === null)
            throw new Error("The parameter 'blockchainProofHash' must be defined and cannot be null.");
        else
            content_ += encodeURIComponent("BlockchainProofHash") + "=" + encodeURIComponent("" + blockchainProofHash) + "&";
        content_ = content_.replace(/&$/, "");

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "BPAASToken": bPAASToken !== undefined && bPAASToken !== null ? "" + bPAASToken : "",
                "BPAASRoles": bPAASRoles !== undefined && bPAASRoles !== null ? "" + bPAASRoles : "",
                "Accept": accept !== undefined && accept !== null ? "" + accept : "",
                "Content-Type": "application/x-www-form-urlencoded",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<Stream> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = Stream.fromJS(resultData200, _mappings);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Stream>(<any>null);
    }
}

export class DownloadFilteredBlockDataDTOClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "https://bpaas-services-ledger.com/";
    }

    /**
     * download filtered block from blockchain ledger
     * @param tenantID BPAAS Multi-Tennant ID
     * @param userID BPAAS UserID
     * @param requestingUserID BPAAS RequestingUserID
     * @param ledgerName BPAAS LedgerName
     * @param blockchainProofHash BPAAS hash of the proof proving that we have rights to the parent blockchain data we are attempting to update.
     * @param blockFilter (optional) BPAAS block filters applied to the data payload in a block.
     * @param bPAASToken (optional) BPAAS security token to authenticate the user making the request.
     * @param bPAASRoles (optional) BPAAS roles of the user making the request.
     * @param body (optional)
     * @param accept Accept Header
     * @return Success
     */
    post(tenantID: string, userID: string, requestingUserID: string, ledgerName: string, blockchainProofHash: string, blockFilter: (any | undefined)[] | null | undefined, bPAASToken: string | null | undefined, bPAASRoles: string | null | undefined, body: Blob | null | undefined, accept: Accept): Promise<Stream> {
        let url_ = this.baseUrl + "/downloadfilteredblock/";
        url_ = url_.replace(/[?&]$/, "");

        let content_ = "";
        if (tenantID === undefined || tenantID === null)
            throw new Error("The parameter 'tenantID' must be defined and cannot be null.");
        else
            content_ += encodeURIComponent("TenantID") + "=" + encodeURIComponent("" + tenantID) + "&";
        if (userID === undefined || userID === null)
            throw new Error("The parameter 'userID' must be defined and cannot be null.");
        else
            content_ += encodeURIComponent("UserID") + "=" + encodeURIComponent("" + userID) + "&";
        if (requestingUserID === undefined || requestingUserID === null)
            throw new Error("The parameter 'requestingUserID' must be defined and cannot be null.");
        else
            content_ += encodeURIComponent("RequestingUserID") + "=" + encodeURIComponent("" + requestingUserID) + "&";
        if (ledgerName === undefined || ledgerName === null)
            throw new Error("The parameter 'ledgerName' must be defined and cannot be null.");
        else
            content_ += encodeURIComponent("LedgerName") + "=" + encodeURIComponent("" + ledgerName) + "&";
        if (blockchainProofHash === undefined || blockchainProofHash === null)
            throw new Error("The parameter 'blockchainProofHash' must be defined and cannot be null.");
        else
            content_ += encodeURIComponent("BlockchainProofHash") + "=" + encodeURIComponent("" + blockchainProofHash) + "&";
        if (blockFilter !== undefined)
            blockFilter && blockFilter.forEach(item => { content_ += encodeURIComponent("BlockFilter") + "=" + encodeURIComponent("" + item) + "&"; });
        content_ = content_.replace(/&$/, "");

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "BPAASToken": bPAASToken !== undefined && bPAASToken !== null ? "" + bPAASToken : "",
                "BPAASRoles": bPAASRoles !== undefined && bPAASRoles !== null ? "" + bPAASRoles : "",
                "Accept": accept !== undefined && accept !== null ? "" + accept : "",
                "Content-Type": "application/x-www-form-urlencoded",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<Stream> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];

        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = Stream.fromJS(resultData200, _mappings);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Stream>(<any>null);
    }
}

export class AssignRolesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "https://bpaas-services-ledger.com/";
    }

    /**
     * @param userName (optional)
     * @param permissions (optional)
     * @param roles (optional)
     * @param meta (optional)
     * @param accept Accept Header
     * @return Success
     */
    get(userName: string | null | undefined, permissions: string | null | undefined, roles: string | null | undefined, meta: string | null | undefined, accept: Accept): Promise<AssignRolesResponse> {
        let url_ = this.baseUrl + "/assignroles?";
        if (userName !== undefined && userName !== null)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (permissions !== undefined && permissions !== null)
            url_ += "Permissions=" + encodeURIComponent("" + permissions) + "&";
        if (roles !== undefined && roles !== null)
            url_ += "Roles=" + encodeURIComponent("" + roles) + "&";
        if (meta !== undefined && meta !== null)
            url_ += "Meta=" + encodeURIComponent("" + meta) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": accept !== undefined && accept !== null ? "" + accept : "",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<AssignRolesResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = AssignRolesResponse.fromJS(resultData200, _mappings);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AssignRolesResponse>(<any>null);
    }

    /**
     * @param userName (optional)
     * @param permissions (optional)
     * @param roles (optional)
     * @param meta (optional)
     * @param body (optional)
     * @param accept Accept Header
     * @return Success
     */
    create(userName: string | null | undefined, permissions: string | null | undefined, roles: string | null | undefined, meta: string | null | undefined, body: AssignRoles | null | undefined, accept: Accept): Promise<AssignRolesResponse> {
        let url_ = this.baseUrl + "/assignroles?";
        if (userName !== undefined && userName !== null)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (permissions !== undefined && permissions !== null)
            url_ += "Permissions=" + encodeURIComponent("" + permissions) + "&";
        if (roles !== undefined && roles !== null)
            url_ += "Roles=" + encodeURIComponent("" + roles) + "&";
        if (meta !== undefined && meta !== null)
            url_ += "Meta=" + encodeURIComponent("" + meta) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Accept": accept !== undefined && accept !== null ? "" + accept : "",
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<AssignRolesResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = AssignRolesResponse.fromJS(resultData200, _mappings);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AssignRolesResponse>(<any>null);
    }

    /**
     * @param userName (optional)
     * @param permissions (optional)
     * @param roles (optional)
     * @param meta (optional)
     * @param body (optional)
     * @param accept Accept Header
     * @return Success
     */
    post(userName: string | null | undefined, permissions: string | null | undefined, roles: string | null | undefined, meta: string | null | undefined, body: AssignRoles | null | undefined, accept: Accept): Promise<AssignRolesResponse> {
        let url_ = this.baseUrl + "/assignroles?";
        if (userName !== undefined && userName !== null)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (permissions !== undefined && permissions !== null)
            url_ += "Permissions=" + encodeURIComponent("" + permissions) + "&";
        if (roles !== undefined && roles !== null)
            url_ += "Roles=" + encodeURIComponent("" + roles) + "&";
        if (meta !== undefined && meta !== null)
            url_ += "Meta=" + encodeURIComponent("" + meta) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Accept": accept !== undefined && accept !== null ? "" + accept : "",
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<AssignRolesResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = AssignRolesResponse.fromJS(resultData200, _mappings);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AssignRolesResponse>(<any>null);
    }

    /**
     * @param userName (optional)
     * @param permissions (optional)
     * @param roles (optional)
     * @param meta (optional)
     * @param accept Accept Header
     * @return Success
     */
    delete(userName: string | null | undefined, permissions: string | null | undefined, roles: string | null | undefined, meta: string | null | undefined, accept: Accept): Promise<AssignRolesResponse> {
        let url_ = this.baseUrl + "/assignroles?";
        if (userName !== undefined && userName !== null)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (permissions !== undefined && permissions !== null)
            url_ += "Permissions=" + encodeURIComponent("" + permissions) + "&";
        if (roles !== undefined && roles !== null)
            url_ += "Roles=" + encodeURIComponent("" + roles) + "&";
        if (meta !== undefined && meta !== null)
            url_ += "Meta=" + encodeURIComponent("" + meta) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Accept": accept !== undefined && accept !== null ? "" + accept : "",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<AssignRolesResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = AssignRolesResponse.fromJS(resultData200, _mappings);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AssignRolesResponse>(<any>null);
    }
}

export class UnAssignRolesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "https://bpaas-services-ledger.com/";
    }

    /**
     * @param userName (optional)
     * @param permissions (optional)
     * @param roles (optional)
     * @param meta (optional)
     * @param accept Accept Header
     * @return Success
     */
    get(userName: string | null | undefined, permissions: string | null | undefined, roles: string | null | undefined, meta: string | null | undefined, accept: Accept): Promise<UnAssignRolesResponse> {
        let url_ = this.baseUrl + "/unassignroles?";
        if (userName !== undefined && userName !== null)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (permissions !== undefined && permissions !== null)
            url_ += "Permissions=" + encodeURIComponent("" + permissions) + "&";
        if (roles !== undefined && roles !== null)
            url_ += "Roles=" + encodeURIComponent("" + roles) + "&";
        if (meta !== undefined && meta !== null)
            url_ += "Meta=" + encodeURIComponent("" + meta) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": accept !== undefined && accept !== null ? "" + accept : "",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<UnAssignRolesResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = UnAssignRolesResponse.fromJS(resultData200, _mappings);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UnAssignRolesResponse>(<any>null);
    }

    /**
     * @param userName (optional)
     * @param permissions (optional)
     * @param roles (optional)
     * @param meta (optional)
     * @param body (optional)
     * @param accept Accept Header
     * @return Success
     */
    create(userName: string | null | undefined, permissions: string | null | undefined, roles: string | null | undefined, meta: string | null | undefined, body: UnAssignRoles | null | undefined, accept: Accept): Promise<UnAssignRolesResponse> {
        let url_ = this.baseUrl + "/unassignroles?";
        if (userName !== undefined && userName !== null)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (permissions !== undefined && permissions !== null)
            url_ += "Permissions=" + encodeURIComponent("" + permissions) + "&";
        if (roles !== undefined && roles !== null)
            url_ += "Roles=" + encodeURIComponent("" + roles) + "&";
        if (meta !== undefined && meta !== null)
            url_ += "Meta=" + encodeURIComponent("" + meta) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Accept": accept !== undefined && accept !== null ? "" + accept : "",
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<UnAssignRolesResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = UnAssignRolesResponse.fromJS(resultData200, _mappings);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UnAssignRolesResponse>(<any>null);
    }

    /**
     * @param userName (optional)
     * @param permissions (optional)
     * @param roles (optional)
     * @param meta (optional)
     * @param body (optional)
     * @param accept Accept Header
     * @return Success
     */
    post(userName: string | null | undefined, permissions: string | null | undefined, roles: string | null | undefined, meta: string | null | undefined, body: UnAssignRoles | null | undefined, accept: Accept): Promise<UnAssignRolesResponse> {
        let url_ = this.baseUrl + "/unassignroles?";
        if (userName !== undefined && userName !== null)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (permissions !== undefined && permissions !== null)
            url_ += "Permissions=" + encodeURIComponent("" + permissions) + "&";
        if (roles !== undefined && roles !== null)
            url_ += "Roles=" + encodeURIComponent("" + roles) + "&";
        if (meta !== undefined && meta !== null)
            url_ += "Meta=" + encodeURIComponent("" + meta) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Accept": accept !== undefined && accept !== null ? "" + accept : "",
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<UnAssignRolesResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = UnAssignRolesResponse.fromJS(resultData200, _mappings);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UnAssignRolesResponse>(<any>null);
    }

    /**
     * @param userName (optional)
     * @param permissions (optional)
     * @param roles (optional)
     * @param meta (optional)
     * @param accept Accept Header
     * @return Success
     */
    delete(userName: string | null | undefined, permissions: string | null | undefined, roles: string | null | undefined, meta: string | null | undefined, accept: Accept): Promise<UnAssignRolesResponse> {
        let url_ = this.baseUrl + "/unassignroles?";
        if (userName !== undefined && userName !== null)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (permissions !== undefined && permissions !== null)
            url_ += "Permissions=" + encodeURIComponent("" + permissions) + "&";
        if (roles !== undefined && roles !== null)
            url_ += "Roles=" + encodeURIComponent("" + roles) + "&";
        if (meta !== undefined && meta !== null)
            url_ += "Meta=" + encodeURIComponent("" + meta) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Accept": accept !== undefined && accept !== null ? "" + accept : "",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<UnAssignRolesResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = UnAssignRolesResponse.fromJS(resultData200, _mappings);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UnAssignRolesResponse>(<any>null);
    }
}

export class RegisterClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "https://bpaas-services-ledger.com/";
    }

    /**
     * @param userName (optional)
     * @param firstName (optional)
     * @param lastName (optional)
     * @param displayName (optional)
     * @param email (optional)
     * @param password (optional)
     * @param confirmPassword (optional)
     * @param autoLogin (optional)
     * @param Continue (optional)
     * @param errorView (optional)
     * @param meta (optional)
     * @param accept Accept Header
     * @return Success
     */
    get(userName: string | null | undefined, firstName: string | null | undefined, lastName: string | null | undefined, displayName: string | null | undefined, email: string | null | undefined, password: string | null | undefined, confirmPassword: string | null | undefined, autoLogin: boolean | null | undefined, Continue: string | null | undefined, errorView: string | null | undefined, meta: string | null | undefined, accept: Accept): Promise<RegisterResponse> {
        let url_ = this.baseUrl + "/register?";
        if (userName !== undefined && userName !== null)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (firstName !== undefined && firstName !== null)
            url_ += "FirstName=" + encodeURIComponent("" + firstName) + "&";
        if (lastName !== undefined && lastName !== null)
            url_ += "LastName=" + encodeURIComponent("" + lastName) + "&";
        if (displayName !== undefined && displayName !== null)
            url_ += "DisplayName=" + encodeURIComponent("" + displayName) + "&";
        if (email !== undefined && email !== null)
            url_ += "Email=" + encodeURIComponent("" + email) + "&";
        if (password !== undefined && password !== null)
            url_ += "Password=" + encodeURIComponent("" + password) + "&";
        if (confirmPassword !== undefined && confirmPassword !== null)
            url_ += "ConfirmPassword=" + encodeURIComponent("" + confirmPassword) + "&";
        if (autoLogin !== undefined && autoLogin !== null)
            url_ += "AutoLogin=" + encodeURIComponent("" + autoLogin) + "&";
        if (Continue !== undefined && Continue !== null)
            url_ += "Continue=" + encodeURIComponent("" + Continue) + "&";
        if (errorView !== undefined && errorView !== null)
            url_ += "ErrorView=" + encodeURIComponent("" + errorView) + "&";
        if (meta !== undefined && meta !== null)
            url_ += "Meta=" + encodeURIComponent("" + meta) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": accept !== undefined && accept !== null ? "" + accept : "",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<RegisterResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = RegisterResponse.fromJS(resultData200, _mappings);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RegisterResponse>(<any>null);
    }

    /**
     * @param userName (optional)
     * @param firstName (optional)
     * @param lastName (optional)
     * @param displayName (optional)
     * @param email (optional)
     * @param password (optional)
     * @param confirmPassword (optional)
     * @param autoLogin (optional)
     * @param Continue (optional)
     * @param errorView (optional)
     * @param meta (optional)
     * @param body (optional)
     * @param accept Accept Header
     * @return Success
     */
    create(userName: string | null | undefined, firstName: string | null | undefined, lastName: string | null | undefined, displayName: string | null | undefined, email: string | null | undefined, password: string | null | undefined, confirmPassword: string | null | undefined, autoLogin: boolean | null | undefined, Continue: string | null | undefined, errorView: string | null | undefined, meta: string | null | undefined, body: Register | null | undefined, accept: Accept): Promise<RegisterResponse> {
        let url_ = this.baseUrl + "/register?";
        if (userName !== undefined && userName !== null)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (firstName !== undefined && firstName !== null)
            url_ += "FirstName=" + encodeURIComponent("" + firstName) + "&";
        if (lastName !== undefined && lastName !== null)
            url_ += "LastName=" + encodeURIComponent("" + lastName) + "&";
        if (displayName !== undefined && displayName !== null)
            url_ += "DisplayName=" + encodeURIComponent("" + displayName) + "&";
        if (email !== undefined && email !== null)
            url_ += "Email=" + encodeURIComponent("" + email) + "&";
        if (password !== undefined && password !== null)
            url_ += "Password=" + encodeURIComponent("" + password) + "&";
        if (confirmPassword !== undefined && confirmPassword !== null)
            url_ += "ConfirmPassword=" + encodeURIComponent("" + confirmPassword) + "&";
        if (autoLogin !== undefined && autoLogin !== null)
            url_ += "AutoLogin=" + encodeURIComponent("" + autoLogin) + "&";
        if (Continue !== undefined && Continue !== null)
            url_ += "Continue=" + encodeURIComponent("" + Continue) + "&";
        if (errorView !== undefined && errorView !== null)
            url_ += "ErrorView=" + encodeURIComponent("" + errorView) + "&";
        if (meta !== undefined && meta !== null)
            url_ += "Meta=" + encodeURIComponent("" + meta) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Accept": accept !== undefined && accept !== null ? "" + accept : "",
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<RegisterResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = RegisterResponse.fromJS(resultData200, _mappings);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RegisterResponse>(<any>null);
    }

    /**
     * @param userName (optional)
     * @param firstName (optional)
     * @param lastName (optional)
     * @param displayName (optional)
     * @param email (optional)
     * @param password (optional)
     * @param confirmPassword (optional)
     * @param autoLogin (optional)
     * @param Continue (optional)
     * @param errorView (optional)
     * @param meta (optional)
     * @param body (optional)
     * @param accept Accept Header
     * @return Success
     */
    post(userName: string | null | undefined, firstName: string | null | undefined, lastName: string | null | undefined, displayName: string | null | undefined, email: string | null | undefined, password: string | null | undefined, confirmPassword: string | null | undefined, autoLogin: boolean | null | undefined, Continue: string | null | undefined, errorView: string | null | undefined, meta: string | null | undefined, body: Register | null | undefined, accept: Accept): Promise<RegisterResponse> {
        let url_ = this.baseUrl + "/register?";
        if (userName !== undefined && userName !== null)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (firstName !== undefined && firstName !== null)
            url_ += "FirstName=" + encodeURIComponent("" + firstName) + "&";
        if (lastName !== undefined && lastName !== null)
            url_ += "LastName=" + encodeURIComponent("" + lastName) + "&";
        if (displayName !== undefined && displayName !== null)
            url_ += "DisplayName=" + encodeURIComponent("" + displayName) + "&";
        if (email !== undefined && email !== null)
            url_ += "Email=" + encodeURIComponent("" + email) + "&";
        if (password !== undefined && password !== null)
            url_ += "Password=" + encodeURIComponent("" + password) + "&";
        if (confirmPassword !== undefined && confirmPassword !== null)
            url_ += "ConfirmPassword=" + encodeURIComponent("" + confirmPassword) + "&";
        if (autoLogin !== undefined && autoLogin !== null)
            url_ += "AutoLogin=" + encodeURIComponent("" + autoLogin) + "&";
        if (Continue !== undefined && Continue !== null)
            url_ += "Continue=" + encodeURIComponent("" + Continue) + "&";
        if (errorView !== undefined && errorView !== null)
            url_ += "ErrorView=" + encodeURIComponent("" + errorView) + "&";
        if (meta !== undefined && meta !== null)
            url_ += "Meta=" + encodeURIComponent("" + meta) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Accept": accept !== undefined && accept !== null ? "" + accept : "",
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<RegisterResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = RegisterResponse.fromJS(resultData200, _mappings);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RegisterResponse>(<any>null);
    }

    /**
     * @param userName (optional)
     * @param firstName (optional)
     * @param lastName (optional)
     * @param displayName (optional)
     * @param email (optional)
     * @param password (optional)
     * @param confirmPassword (optional)
     * @param autoLogin (optional)
     * @param Continue (optional)
     * @param errorView (optional)
     * @param meta (optional)
     * @param accept Accept Header
     * @return Success
     */
    delete(userName: string | null | undefined, firstName: string | null | undefined, lastName: string | null | undefined, displayName: string | null | undefined, email: string | null | undefined, password: string | null | undefined, confirmPassword: string | null | undefined, autoLogin: boolean | null | undefined, Continue: string | null | undefined, errorView: string | null | undefined, meta: string | null | undefined, accept: Accept): Promise<RegisterResponse> {
        let url_ = this.baseUrl + "/register?";
        if (userName !== undefined && userName !== null)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (firstName !== undefined && firstName !== null)
            url_ += "FirstName=" + encodeURIComponent("" + firstName) + "&";
        if (lastName !== undefined && lastName !== null)
            url_ += "LastName=" + encodeURIComponent("" + lastName) + "&";
        if (displayName !== undefined && displayName !== null)
            url_ += "DisplayName=" + encodeURIComponent("" + displayName) + "&";
        if (email !== undefined && email !== null)
            url_ += "Email=" + encodeURIComponent("" + email) + "&";
        if (password !== undefined && password !== null)
            url_ += "Password=" + encodeURIComponent("" + password) + "&";
        if (confirmPassword !== undefined && confirmPassword !== null)
            url_ += "ConfirmPassword=" + encodeURIComponent("" + confirmPassword) + "&";
        if (autoLogin !== undefined && autoLogin !== null)
            url_ += "AutoLogin=" + encodeURIComponent("" + autoLogin) + "&";
        if (Continue !== undefined && Continue !== null)
            url_ += "Continue=" + encodeURIComponent("" + Continue) + "&";
        if (errorView !== undefined && errorView !== null)
            url_ += "ErrorView=" + encodeURIComponent("" + errorView) + "&";
        if (meta !== undefined && meta !== null)
            url_ += "Meta=" + encodeURIComponent("" + meta) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Accept": accept !== undefined && accept !== null ? "" + accept : "",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<RegisterResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = RegisterResponse.fromJS(resultData200, _mappings);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RegisterResponse>(<any>null);
    }
}

export class GetApiKeysClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "https://bpaas-services-ledger.com/";
    }

    /**
     * @param environment (optional)
     * @param meta (optional)
     * @param accept Accept Header
     * @return Success
     */
    get(environment: string | null | undefined, meta: string | null | undefined, accept: Accept): Promise<GetApiKeysResponse> {
        let url_ = this.baseUrl + "/apikeys?";
        if (environment !== undefined && environment !== null)
            url_ += "Environment=" + encodeURIComponent("" + environment) + "&";
        if (meta !== undefined && meta !== null)
            url_ += "Meta=" + encodeURIComponent("" + meta) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": accept !== undefined && accept !== null ? "" + accept : "",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<GetApiKeysResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = GetApiKeysResponse.fromJS(resultData200, _mappings);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GetApiKeysResponse>(<any>null);
    }

    /**
     * @param environment (optional)
     * @param meta (optional)
     * @param body (optional)
     * @param accept Accept Header
     * @return Success
     */
    create(environment: string | null | undefined, meta: string | null | undefined, body: GetApiKeys | null | undefined, accept: Accept): Promise<GetApiKeysResponse> {
        let url_ = this.baseUrl + "/apikeys?";
        if (environment !== undefined && environment !== null)
            url_ += "Environment=" + encodeURIComponent("" + environment) + "&";
        if (meta !== undefined && meta !== null)
            url_ += "Meta=" + encodeURIComponent("" + meta) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Accept": accept !== undefined && accept !== null ? "" + accept : "",
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<GetApiKeysResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = GetApiKeysResponse.fromJS(resultData200, _mappings);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GetApiKeysResponse>(<any>null);
    }

    /**
     * @param environment (optional)
     * @param meta (optional)
     * @param body (optional)
     * @param accept Accept Header
     * @return Success
     */
    post(environment: string | null | undefined, meta: string | null | undefined, body: GetApiKeys | null | undefined, accept: Accept): Promise<GetApiKeysResponse> {
        let url_ = this.baseUrl + "/apikeys?";
        if (environment !== undefined && environment !== null)
            url_ += "Environment=" + encodeURIComponent("" + environment) + "&";
        if (meta !== undefined && meta !== null)
            url_ += "Meta=" + encodeURIComponent("" + meta) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Accept": accept !== undefined && accept !== null ? "" + accept : "",
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPost(_response);
        });
    }

    protected processPost(response: Response): Promise<GetApiKeysResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = GetApiKeysResponse.fromJS(resultData200, _mappings);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GetApiKeysResponse>(<any>null);
    }

    /**
     * @param environment (optional)
     * @param meta (optional)
     * @param accept Accept Header
     * @return Success
     */
    delete(environment: string | null | undefined, meta: string | null | undefined, accept: Accept): Promise<GetApiKeysResponse> {
        let url_ = this.baseUrl + "/apikeys?";
        if (environment !== undefined && environment !== null)
            url_ += "Environment=" + encodeURIComponent("" + environment) + "&";
        if (meta !== undefined && meta !== null)
            url_ += "Meta=" + encodeURIComponent("" + meta) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
                "Accept": accept !== undefined && accept !== null ? "" + accept : "",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: Response): Promise<GetApiKeysResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        let _mappings: { source: any, target: any }[] = [];
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : jsonParse(_responseText, this.jsonParseReviver);
            result200 = GetApiKeysResponse.fromJS(resultData200, _mappings);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GetApiKeysResponse>(<any>null);
    }
}

/** Object */
export class Object implements IObject {

    constructor(data?: IObject) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
    }

    static fromJS(data: any, _mappings?: any): Object {
        data = typeof data === 'object' ? data : {};
        return createInstance<Object>(data, _mappings, Object);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

/** Object */
export interface IObject {
}

/** Get misc. environment information. */
export class GetIPAddressInfoRequestDTO implements IGetIPAddressInfoRequestDTO {

    constructor(data?: IGetIPAddressInfoRequestDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
    }

    static fromJS(data: any, _mappings?: any): GetIPAddressInfoRequestDTO {
        data = typeof data === 'object' ? data : {};
        return createInstance<GetIPAddressInfoRequestDTO>(data, _mappings, GetIPAddressInfoRequestDTO);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

/** Get misc. environment information. */
export interface IGetIPAddressInfoRequestDTO {
}

/** An api to grant access rights to a user for a blockchain you created for a BPAAS tenant. */
export class GrantBlockchainAccessDTO implements IGrantBlockchainAccessDTO {
    /** BPAAS Multi-Tennant ID */
    tenantID!: string;
    /** BPAAS UserID */
    userID!: string;
    /** BPAAS RequestingUserID */
    requestingUserID!: string;
    /** BPAAS GrantedUserID */
    grantedUserID!: string;
    /** BPAAS UpdatedByUserID */
    dateTimeStamp?: any | undefined;
    /** BPAAS LedgerName */
    ledgerName!: string;
    /** BPAAS hash of the proof proving that we have rights to the parent blockchain data we are attempting to update. */
    blockchainProofHash!: string;
    /** BPAAS security token to authenticate the user making the request. */
    bPAASToken?: string | undefined;
    /** BPAAS roles of the user making the request. */
    bPAASRoles?: string | undefined;

    constructor(data?: IGrantBlockchainAccessDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.tenantID = _data["TenantID"];
            this.userID = _data["UserID"];
            this.requestingUserID = _data["RequestingUserID"];
            this.grantedUserID = _data["GrantedUserID"];
            this.dateTimeStamp = _data["DateTimeStamp"] ? new Date(_data["DateTimeStamp"].toString()) : <any>undefined;
            this.ledgerName = _data["LedgerName"];
            this.blockchainProofHash = _data["BlockchainProofHash"];
            this.bPAASToken = _data["BPAASToken"];
            this.bPAASRoles = _data["BPAASRoles"];
        }
    }

    static fromJS(data: any, _mappings?: any): GrantBlockchainAccessDTO {
        data = typeof data === 'object' ? data : {};
        return createInstance<GrantBlockchainAccessDTO>(data, _mappings, GrantBlockchainAccessDTO);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["TenantID"] = this.tenantID;
        data["UserID"] = this.userID;
        data["RequestingUserID"] = this.requestingUserID;
        data["GrantedUserID"] = this.grantedUserID;
        data["DateTimeStamp"] = this.dateTimeStamp ? this.dateTimeStamp.toISOString() : <any>undefined;
        data["LedgerName"] = this.ledgerName;
        data["BlockchainProofHash"] = this.blockchainProofHash;
        data["BPAASToken"] = this.bPAASToken;
        data["BPAASRoles"] = this.bPAASRoles;
        return data;
    }
}

/** An api to grant access rights to a user for a blockchain you created for a BPAAS tenant. */
export interface IGrantBlockchainAccessDTO {
    /** BPAAS Multi-Tennant ID */
    tenantID: string;
    /** BPAAS UserID */
    userID: string;
    /** BPAAS RequestingUserID */
    requestingUserID: string;
    /** BPAAS GrantedUserID */
    grantedUserID: string;
    /** BPAAS UpdatedByUserID */
    dateTimeStamp?: any | undefined;
    /** BPAAS LedgerName */
    ledgerName: string;
    /** BPAAS hash of the proof proving that we have rights to the parent blockchain data we are attempting to update. */
    blockchainProofHash: string;
    /** BPAAS security token to authenticate the user making the request. */
    bPAASToken?: string | undefined;
    /** BPAAS roles of the user making the request. */
    bPAASRoles?: string | undefined;
}

/** An api to get all authorized users for a specific ledger. */
export class GetAuthorizedUsersDTO implements IGetAuthorizedUsersDTO {
    /** BPAAS Multi-Tennant ID */
    tenantID!: string;
    /** BPAAS UserID */
    userID!: string;
    /** BPAAS RequestingUserID */
    requestingUserID!: string;
    /** BPAAS LedgerName */
    ledgerName!: string;
    /** BPAAS hash of the proof proving that we have rights to the parent blockchain data we are attempting to update. */
    blockchainProofHash!: string;
    /** BPAAS security token to authenticate the user making the request. */
    bPAASToken?: string | undefined;
    /** BPAAS roles of the user making the request. */
    bPAASRoles?: string | undefined;

    constructor(data?: IGetAuthorizedUsersDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.tenantID = _data["TenantID"];
            this.userID = _data["UserID"];
            this.requestingUserID = _data["RequestingUserID"];
            this.ledgerName = _data["LedgerName"];
            this.blockchainProofHash = _data["BlockchainProofHash"];
            this.bPAASToken = _data["BPAASToken"];
            this.bPAASRoles = _data["BPAASRoles"];
        }
    }

    static fromJS(data: any, _mappings?: any): GetAuthorizedUsersDTO {
        data = typeof data === 'object' ? data : {};
        return createInstance<GetAuthorizedUsersDTO>(data, _mappings, GetAuthorizedUsersDTO);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["TenantID"] = this.tenantID;
        data["UserID"] = this.userID;
        data["RequestingUserID"] = this.requestingUserID;
        data["LedgerName"] = this.ledgerName;
        data["BlockchainProofHash"] = this.blockchainProofHash;
        data["BPAASToken"] = this.bPAASToken;
        data["BPAASRoles"] = this.bPAASRoles;
        return data;
    }
}

/** An api to get all authorized users for a specific ledger. */
export interface IGetAuthorizedUsersDTO {
    /** BPAAS Multi-Tennant ID */
    tenantID: string;
    /** BPAAS UserID */
    userID: string;
    /** BPAAS RequestingUserID */
    requestingUserID: string;
    /** BPAAS LedgerName */
    ledgerName: string;
    /** BPAAS hash of the proof proving that we have rights to the parent blockchain data we are attempting to update. */
    blockchainProofHash: string;
    /** BPAAS security token to authenticate the user making the request. */
    bPAASToken?: string | undefined;
    /** BPAAS roles of the user making the request. */
    bPAASRoles?: string | undefined;
}

/** An api to grant access rights from a user for a blockchain you created for a BPAAS tenant. */
export class RevokeBlockchainAccessDTO implements IRevokeBlockchainAccessDTO {
    /** BPAAS Multi-Tennant ID */
    tenantID!: string;
    /** BPAAS UserID */
    userID!: string;
    /** BPAAS RequestingUserID */
    requestingUserID!: string;
    /** BPAAS GrantedUserID */
    revokedUserID!: string;
    /** BPAAS UpdatedByUserID */
    dateTimeStamp?: any | undefined;
    /** BPAAS LedgerName */
    ledgerName!: string;
    /** BPAAS hash of the proof proving that we have rights to the parent blockchain data we are attempting to update. */
    blockchainProofHash!: string;
    /** BPAAS security token to authenticate the user making the request. */
    bPAASToken?: string | undefined;
    /** BPAAS roles of the user making the request. */
    bPAASRoles?: string | undefined;

    constructor(data?: IRevokeBlockchainAccessDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.tenantID = _data["TenantID"];
            this.userID = _data["UserID"];
            this.requestingUserID = _data["RequestingUserID"];
            this.revokedUserID = _data["RevokedUserID"];
            this.dateTimeStamp = _data["DateTimeStamp"] ? new Date(_data["DateTimeStamp"].toString()) : <any>undefined;
            this.ledgerName = _data["LedgerName"];
            this.blockchainProofHash = _data["BlockchainProofHash"];
            this.bPAASToken = _data["BPAASToken"];
            this.bPAASRoles = _data["BPAASRoles"];
        }
    }

    static fromJS(data: any, _mappings?: any): RevokeBlockchainAccessDTO {
        data = typeof data === 'object' ? data : {};
        return createInstance<RevokeBlockchainAccessDTO>(data, _mappings, RevokeBlockchainAccessDTO);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["TenantID"] = this.tenantID;
        data["UserID"] = this.userID;
        data["RequestingUserID"] = this.requestingUserID;
        data["RevokedUserID"] = this.revokedUserID;
        data["DateTimeStamp"] = this.dateTimeStamp ? this.dateTimeStamp.toISOString() : <any>undefined;
        data["LedgerName"] = this.ledgerName;
        data["BlockchainProofHash"] = this.blockchainProofHash;
        data["BPAASToken"] = this.bPAASToken;
        data["BPAASRoles"] = this.bPAASRoles;
        return data;
    }
}

/** An api to grant access rights from a user for a blockchain you created for a BPAAS tenant. */
export interface IRevokeBlockchainAccessDTO {
    /** BPAAS Multi-Tennant ID */
    tenantID: string;
    /** BPAAS UserID */
    userID: string;
    /** BPAAS RequestingUserID */
    requestingUserID: string;
    /** BPAAS GrantedUserID */
    revokedUserID: string;
    /** BPAAS UpdatedByUserID */
    dateTimeStamp?: any | undefined;
    /** BPAAS LedgerName */
    ledgerName: string;
    /** BPAAS hash of the proof proving that we have rights to the parent blockchain data we are attempting to update. */
    blockchainProofHash: string;
    /** BPAAS security token to authenticate the user making the request. */
    bPAASToken?: string | undefined;
    /** BPAAS roles of the user making the request. */
    bPAASRoles?: string | undefined;
}

/** An api to create a blockchain ledger for a BPAAS tenant. */
export class CreateBlockchainLedgerDTO implements ICreateBlockchainLedgerDTO {
    /** BPAAS Multi-Tennant ID */
    tenantID!: string;
    /** BPAAS UserID */
    userID!: string;
    /** BPAAS RequestingUserID */
    requestingUserID!: string;
    /** BPAAS UpdatedByUserID */
    updatedByUserID!: string;
    /** BPAAS UpdatedByUserID */
    dateTimeStamp?: any | undefined;
    /** BPAAS LedgerName */
    ledgerName!: string;
    /** BPAAS Ledger Description */
    ledgerDescription!: string;
    /** BPAAS flag signifying if a blockchain is public or private.  If private only specific users can modify the blockchain. */
    isLocked?: any | undefined;
    /** BPAAS assigned roles of the ledger. */
    assignedRoles!: string;
    /** BPAAS security token to authenticate the user making the request. */
    bPAASToken?: string | undefined;
    /** BPAAS roles of the user making the request. */
    bPAASRoles?: string | undefined;

    constructor(data?: ICreateBlockchainLedgerDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.tenantID = _data["TenantID"];
            this.userID = _data["UserID"];
            this.requestingUserID = _data["RequestingUserID"];
            this.updatedByUserID = _data["UpdatedByUserID"];
            this.dateTimeStamp = _data["DateTimeStamp"] ? new Date(_data["DateTimeStamp"].toString()) : <any>undefined;
            this.ledgerName = _data["LedgerName"];
            this.ledgerDescription = _data["LedgerDescription"];
            this.isLocked = _data["IsLocked"];
            this.assignedRoles = _data["AssignedRoles"];
            this.bPAASToken = _data["BPAASToken"];
            this.bPAASRoles = _data["BPAASRoles"];
        }
    }

    static fromJS(data: any, _mappings?: any): CreateBlockchainLedgerDTO {
        data = typeof data === 'object' ? data : {};
        return createInstance<CreateBlockchainLedgerDTO>(data, _mappings, CreateBlockchainLedgerDTO);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["TenantID"] = this.tenantID;
        data["UserID"] = this.userID;
        data["RequestingUserID"] = this.requestingUserID;
        data["UpdatedByUserID"] = this.updatedByUserID;
        data["DateTimeStamp"] = this.dateTimeStamp ? this.dateTimeStamp.toISOString() : <any>undefined;
        data["LedgerName"] = this.ledgerName;
        data["LedgerDescription"] = this.ledgerDescription;
        data["IsLocked"] = this.isLocked;
        data["AssignedRoles"] = this.assignedRoles;
        data["BPAASToken"] = this.bPAASToken;
        data["BPAASRoles"] = this.bPAASRoles;
        return data;
    }
}

/** An api to create a blockchain ledger for a BPAAS tenant. */
export interface ICreateBlockchainLedgerDTO {
    /** BPAAS Multi-Tennant ID */
    tenantID: string;
    /** BPAAS UserID */
    userID: string;
    /** BPAAS RequestingUserID */
    requestingUserID: string;
    /** BPAAS UpdatedByUserID */
    updatedByUserID: string;
    /** BPAAS UpdatedByUserID */
    dateTimeStamp?: any | undefined;
    /** BPAAS LedgerName */
    ledgerName: string;
    /** BPAAS Ledger Description */
    ledgerDescription: string;
    /** BPAAS flag signifying if a blockchain is public or private.  If private only specific users can modify the blockchain. */
    isLocked?: any | undefined;
    /** BPAAS assigned roles of the ledger. */
    assignedRoles: string;
    /** BPAAS security token to authenticate the user making the request. */
    bPAASToken?: string | undefined;
    /** BPAAS roles of the user making the request. */
    bPAASRoles?: string | undefined;
}

/** An api to add a block to a blockchain ledger for a BPAAS tenant. */
export class AddToBlockchainLedgerDTO implements IAddToBlockchainLedgerDTO {
    /** BPAAS Multi-Tennant ID */
    tenantID!: string;
    /** BPAAS UserID */
    userID!: string;
    /** BPAAS RequestingUserID */
    requestingUserID!: string;
    /** BPAAS UpdatedByUserID */
    updatedByUserID!: string;
    /** BPAAS UpdatedByUserID */
    dateTimeStamp?: any | undefined;
    /** BPAAS LedgerName */
    ledgerName!: string;
    /** BPAAS IsFile */
    isFile?: any | undefined;
    /** BPAAS FileExtension */
    fileExtension?: string | undefined;
    /** BPAAS SaveTextAsFile */
    saveTextAsFile?: any | undefined;
    /** BPAAS is this a smart contract block document. */
    isSmartContract?: any | undefined;
    /** BPAAS Block name */
    blockName!: string;
    /** BPAAS Description of the block. */
    blockDescription?: string | undefined;
    /** BPAAS hash of the proof proving that we have rights to the block data we are attempting to update. */
    blockProofHash?: string | undefined;
    /** BPAAS hash of the proof proving that we have rights to the parent blockchain data we are attempting to update. */
    blockchainProofHash!: string;
    /** BPAAS flag signifying if a block is active or not. */
    isActive?: any | undefined;
    requestStream?: Stream | undefined;
    /** BPAAS security token to authenticate the user making the request. */
    bPAASToken?: string | undefined;
    /** BPAAS roles of the user making the request. */
    bPAASRoles?: string | undefined;

    constructor(data?: IAddToBlockchainLedgerDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.tenantID = _data["TenantID"];
            this.userID = _data["UserID"];
            this.requestingUserID = _data["RequestingUserID"];
            this.updatedByUserID = _data["UpdatedByUserID"];
            this.dateTimeStamp = _data["DateTimeStamp"] ? new Date(_data["DateTimeStamp"].toString()) : <any>undefined;
            this.ledgerName = _data["LedgerName"];
            this.isFile = _data["IsFile"];
            this.fileExtension = _data["FileExtension"];
            this.saveTextAsFile = _data["SaveTextAsFile"];
            this.isSmartContract = _data["IsSmartContract"];
            this.blockName = _data["BlockName"];
            this.blockDescription = _data["BlockDescription"];
            this.blockProofHash = _data["BlockProofHash"];
            this.blockchainProofHash = _data["BlockchainProofHash"];
            this.isActive = _data["IsActive"];
            this.requestStream = _data["RequestStream"] ? Stream.fromJS(_data["RequestStream"], _mappings) : <any>undefined;
            this.bPAASToken = _data["BPAASToken"];
            this.bPAASRoles = _data["BPAASRoles"];
        }
    }

    static fromJS(data: any, _mappings?: any): AddToBlockchainLedgerDTO {
        data = typeof data === 'object' ? data : {};
        return createInstance<AddToBlockchainLedgerDTO>(data, _mappings, AddToBlockchainLedgerDTO);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["TenantID"] = this.tenantID;
        data["UserID"] = this.userID;
        data["RequestingUserID"] = this.requestingUserID;
        data["UpdatedByUserID"] = this.updatedByUserID;
        data["DateTimeStamp"] = this.dateTimeStamp ? this.dateTimeStamp.toString() : <any>undefined;
        data["LedgerName"] = this.ledgerName;
        data["IsFile"] = this.isFile;
        data["FileExtension"] = this.fileExtension;
        data["SaveTextAsFile"] = this.saveTextAsFile;
        data["IsSmartContract"] = this.isSmartContract;
        data["BlockName"] = this.blockName;
        data["BlockDescription"] = this.blockDescription;
        data["BlockProofHash"] = this.blockProofHash;
        data["BlockchainProofHash"] = this.blockchainProofHash;
        data["IsActive"] = this.isActive;
        data["RequestStream"] = this.requestStream ? this.requestStream.toJSON() : <any>undefined;
        data["BPAASToken"] = this.bPAASToken;
        data["BPAASRoles"] = this.bPAASRoles;
        return data;
    }
}

/** An api to add a block to a blockchain ledger for a BPAAS tenant. */
export interface IAddToBlockchainLedgerDTO {
    /** BPAAS Multi-Tennant ID */
    tenantID: string;
    /** BPAAS UserID */
    userID: string;
    /** BPAAS RequestingUserID */
    requestingUserID: string;
    /** BPAAS UpdatedByUserID */
    updatedByUserID: string;
    /** BPAAS UpdatedByUserID */
    dateTimeStamp?: any | undefined;
    /** BPAAS LedgerName */
    ledgerName: string;
    /** BPAAS IsFile */
    isFile?: any | undefined;
    /** BPAAS FileExtension */
    fileExtension?: string | undefined;
    /** BPAAS SaveTextAsFile */
    saveTextAsFile?: any | undefined;
    /** BPAAS is this a smart contract block document. */
    isSmartContract?: any | undefined;
    /** BPAAS Block name */
    blockName: string;
    /** BPAAS Description of the block. */
    blockDescription?: string | undefined;
    /** BPAAS hash of the proof proving that we have rights to the block data we are attempting to update. */
    blockProofHash?: string | undefined;
    /** BPAAS hash of the proof proving that we have rights to the parent blockchain data we are attempting to update. */
    blockchainProofHash: string;
    /** BPAAS flag signifying if a block is active or not. */
    isActive?: any | undefined;
    requestStream?: Stream | undefined;
    /** BPAAS security token to authenticate the user making the request. */
    bPAASToken?: string | undefined;
    /** BPAAS roles of the user making the request. */
    bPAASRoles?: string | undefined;
}

/** Stream */
export class Stream implements IStream {

    constructor(data?: IStream) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
    }

    static fromJS(data: any, _mappings?: any): Stream {
        data = typeof data === 'object' ? data : {};
        return createInstance<Stream>(data, _mappings, Stream);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

/** Stream */
export interface IStream {
}

/** An api to delete a block from a blockchain ledger for a BPAAS tenant. */
export class DeleteFromBlockchainLedgerDTO implements IDeleteFromBlockchainLedgerDTO {
    /** BPAAS Multi-Tennant ID */
    tenantID!: string;
    /** BPAAS UserID */
    userID!: string;
    /** BPAAS RequestingUserID */
    requestingUserID!: string;
    /** BPAAS UpdatedByUserID */
    updatedByUserID!: string;
    /** BPAAS LedgerName */
    ledgerName!: string;
    /** BPAAS UpdatedByUserID */
    dateTimeStamp?: any | undefined;
    /** BPAAS Block name */
    blockName!: string;
    /** BPAAS hash of the proof proving that we have rights to the block data we are attempting to update. */
    blockProofHash!: string;
    /** BPAAS hash of the proof proving that we have rights to the parent blockchain data we are attempting to update. */
    blockchainProofHash!: string;
    /** BPAAS security token to authenticate the user making the request. */
    bPAASToken?: string | undefined;
    /** BPAAS roles of the user making the request. */
    bPAASRoles?: string | undefined;

    constructor(data?: IDeleteFromBlockchainLedgerDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.tenantID = _data["TenantID"];
            this.userID = _data["UserID"];
            this.requestingUserID = _data["RequestingUserID"];
            this.updatedByUserID = _data["UpdatedByUserID"];
            this.ledgerName = _data["LedgerName"];
            this.dateTimeStamp = _data["DateTimeStamp"] ? new Date(_data["DateTimeStamp"].toString()) : <any>undefined;
            this.blockName = _data["BlockName"];
            this.blockProofHash = _data["BlockProofHash"];
            this.blockchainProofHash = _data["BlockchainProofHash"];
            this.bPAASToken = _data["BPAASToken"];
            this.bPAASRoles = _data["BPAASRoles"];
        }
    }

    static fromJS(data: any, _mappings?: any): DeleteFromBlockchainLedgerDTO {
        data = typeof data === 'object' ? data : {};
        return createInstance<DeleteFromBlockchainLedgerDTO>(data, _mappings, DeleteFromBlockchainLedgerDTO);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["TenantID"] = this.tenantID;
        data["UserID"] = this.userID;
        data["RequestingUserID"] = this.requestingUserID;
        data["UpdatedByUserID"] = this.updatedByUserID;
        data["LedgerName"] = this.ledgerName;
        data["DateTimeStamp"] = this.dateTimeStamp ? this.dateTimeStamp.toISOString() : <any>undefined;
        data["BlockName"] = this.blockName;
        data["BlockProofHash"] = this.blockProofHash;
        data["BlockchainProofHash"] = this.blockchainProofHash;
        data["BPAASToken"] = this.bPAASToken;
        data["BPAASRoles"] = this.bPAASRoles;
        return data;
    }
}

/** An api to delete a block from a blockchain ledger for a BPAAS tenant. */
export interface IDeleteFromBlockchainLedgerDTO {
    /** BPAAS Multi-Tennant ID */
    tenantID: string;
    /** BPAAS UserID */
    userID: string;
    /** BPAAS RequestingUserID */
    requestingUserID: string;
    /** BPAAS UpdatedByUserID */
    updatedByUserID: string;
    /** BPAAS LedgerName */
    ledgerName: string;
    /** BPAAS UpdatedByUserID */
    dateTimeStamp?: any | undefined;
    /** BPAAS Block name */
    blockName: string;
    /** BPAAS hash of the proof proving that we have rights to the block data we are attempting to update. */
    blockProofHash: string;
    /** BPAAS hash of the proof proving that we have rights to the parent blockchain data we are attempting to update. */
    blockchainProofHash: string;
    /** BPAAS security token to authenticate the user making the request. */
    bPAASToken?: string | undefined;
    /** BPAAS roles of the user making the request. */
    bPAASRoles?: string | undefined;
}

/** An api to lock a blockchain ledger for a BPAAS tenant. */
export class LockBlockchainLedgerDTO implements ILockBlockchainLedgerDTO {
    /** BPAAS Multi-Tennant ID */
    tenantID!: string;
    /** BPAAS UserID */
    userID!: string;
    /** BPAAS RequestingUserID */
    requestingUserID!: string;
    /** BPAAS UpdatedByUserID */
    dateTimeStamp?: any | undefined;
    /** BPAAS LedgerName */
    ledgerName!: string;
    /** BPAAS flag signifying if a blockchain is public or private.  If private only specific users can modify the blockchain. */
    isPublic?: any | undefined;
    /** BPAAS hash of the proof proving that we have rights to the parent blockchain data we are attempting to update. */
    blockchainProofHash!: string;
    /** BPAAS security token to authenticate the user making the request. */
    bPAASToken?: string | undefined;
    /** BPAAS roles of the user making the request. */
    bPAASRoles?: string | undefined;

    constructor(data?: ILockBlockchainLedgerDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.tenantID = _data["TenantID"];
            this.userID = _data["UserID"];
            this.requestingUserID = _data["RequestingUserID"];
            this.dateTimeStamp = _data["DateTimeStamp"] ? new Date(_data["DateTimeStamp"].toString()) : <any>undefined;
            this.ledgerName = _data["LedgerName"];
            this.isPublic = _data["IsPublic"];
            this.blockchainProofHash = _data["BlockchainProofHash"];
            this.bPAASToken = _data["BPAASToken"];
            this.bPAASRoles = _data["BPAASRoles"];
        }
    }

    static fromJS(data: any, _mappings?: any): LockBlockchainLedgerDTO {
        data = typeof data === 'object' ? data : {};
        return createInstance<LockBlockchainLedgerDTO>(data, _mappings, LockBlockchainLedgerDTO);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["TenantID"] = this.tenantID;
        data["UserID"] = this.userID;
        data["RequestingUserID"] = this.requestingUserID;
        data["DateTimeStamp"] = this.dateTimeStamp ? this.dateTimeStamp.toISOString() : <any>undefined;
        data["LedgerName"] = this.ledgerName;
        data["IsPublic"] = this.isPublic;
        data["BlockchainProofHash"] = this.blockchainProofHash;
        data["BPAASToken"] = this.bPAASToken;
        data["BPAASRoles"] = this.bPAASRoles;
        return data;
    }
}

/** An api to lock a blockchain ledger for a BPAAS tenant. */
export interface ILockBlockchainLedgerDTO {
    /** BPAAS Multi-Tennant ID */
    tenantID: string;
    /** BPAAS UserID */
    userID: string;
    /** BPAAS RequestingUserID */
    requestingUserID: string;
    /** BPAAS UpdatedByUserID */
    dateTimeStamp?: any | undefined;
    /** BPAAS LedgerName */
    ledgerName: string;
    /** BPAAS flag signifying if a blockchain is public or private.  If private only specific users can modify the blockchain. */
    isPublic?: any | undefined;
    /** BPAAS hash of the proof proving that we have rights to the parent blockchain data we are attempting to update. */
    blockchainProofHash: string;
    /** BPAAS security token to authenticate the user making the request. */
    bPAASToken?: string | undefined;
    /** BPAAS roles of the user making the request. */
    bPAASRoles?: string | undefined;
}

/** An api to unlock a blockchain ledger for a BPAAS tenant. */
export class UnLockBlockchainLedgerDTO implements IUnLockBlockchainLedgerDTO {
    /** BPAAS Multi-Tennant ID */
    tenantID!: string;
    /** BPAAS UserID */
    userID!: string;
    /** BPAAS RequestingUserID */
    requestingUserID!: string;
    /** BPAAS UpdatedByUserID */
    dateTimeStamp?: any | undefined;
    /** BPAAS LedgerName */
    ledgerName!: string;
    /** BPAAS flag signifying if a blockchain is public or private.  If private only specific users can modify the blockchain. */
    isPublic?: any | undefined;
    /** BPAAS hash of the proof proving that we have rights to the parent blockchain data we are attempting to update. */
    blockchainProofHash!: string;
    /** BPAAS security token to authenticate the user making the request. */
    bPAASToken?: string | undefined;
    /** BPAAS roles of the user making the request. */
    bPAASRoles?: string | undefined;

    constructor(data?: IUnLockBlockchainLedgerDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.tenantID = _data["TenantID"];
            this.userID = _data["UserID"];
            this.requestingUserID = _data["RequestingUserID"];
            this.dateTimeStamp = _data["DateTimeStamp"] ? new Date(_data["DateTimeStamp"].toString()) : <any>undefined;
            this.ledgerName = _data["LedgerName"];
            this.isPublic = _data["IsPublic"];
            this.blockchainProofHash = _data["BlockchainProofHash"];
            this.bPAASToken = _data["BPAASToken"];
            this.bPAASRoles = _data["BPAASRoles"];
        }
    }

    static fromJS(data: any, _mappings?: any): UnLockBlockchainLedgerDTO {
        data = typeof data === 'object' ? data : {};
        return createInstance<UnLockBlockchainLedgerDTO>(data, _mappings, UnLockBlockchainLedgerDTO);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["TenantID"] = this.tenantID;
        data["UserID"] = this.userID;
        data["RequestingUserID"] = this.requestingUserID;
        data["DateTimeStamp"] = this.dateTimeStamp ? this.dateTimeStamp.toISOString() : <any>undefined;
        data["LedgerName"] = this.ledgerName;
        data["IsPublic"] = this.isPublic;
        data["BlockchainProofHash"] = this.blockchainProofHash;
        data["BPAASToken"] = this.bPAASToken;
        data["BPAASRoles"] = this.bPAASRoles;
        return data;
    }
}

/** An api to unlock a blockchain ledger for a BPAAS tenant. */
export interface IUnLockBlockchainLedgerDTO {
    /** BPAAS Multi-Tennant ID */
    tenantID: string;
    /** BPAAS UserID */
    userID: string;
    /** BPAAS RequestingUserID */
    requestingUserID: string;
    /** BPAAS UpdatedByUserID */
    dateTimeStamp?: any | undefined;
    /** BPAAS LedgerName */
    ledgerName: string;
    /** BPAAS flag signifying if a blockchain is public or private.  If private only specific users can modify the blockchain. */
    isPublic?: any | undefined;
    /** BPAAS hash of the proof proving that we have rights to the parent blockchain data we are attempting to update. */
    blockchainProofHash: string;
    /** BPAAS security token to authenticate the user making the request. */
    bPAASToken?: string | undefined;
    /** BPAAS roles of the user making the request. */
    bPAASRoles?: string | undefined;
}

/** An api to return all blockchains within a blockchain ledger for a BPAAS tenant. */
export class GetAllBlockchainsByTenantIDDTO implements IGetAllBlockchainsByTenantIDDTO {
    /** BPAAS Multi-Tennant ID */
    tenantID!: string;
    /** BPAAS Multi-Tennant UserID */
    userID!: string;
    /** BPAAS security token to authenticate the user making the request. */
    bPAASToken?: string | undefined;
    /** BPAAS roles of the user making the request. */
    bPAASRoles?: string | undefined;

    constructor(data?: IGetAllBlockchainsByTenantIDDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.tenantID = _data["TenantID"];
            this.userID = _data["UserID"];
            this.bPAASToken = _data["BPAASToken"];
            this.bPAASRoles = _data["BPAASRoles"];
        }
    }

    static fromJS(data: any, _mappings?: any): GetAllBlockchainsByTenantIDDTO {
        data = typeof data === 'object' ? data : {};
        return createInstance<GetAllBlockchainsByTenantIDDTO>(data, _mappings, GetAllBlockchainsByTenantIDDTO);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["TenantID"] = this.tenantID;
        data["UserID"] = this.userID;
        data["BPAASToken"] = this.bPAASToken;
        data["BPAASRoles"] = this.bPAASRoles;
        return data;
    }
}

/** An api to return all blockchains within a blockchain ledger for a BPAAS tenant. */
export interface IGetAllBlockchainsByTenantIDDTO {
    /** BPAAS Multi-Tennant ID */
    tenantID: string;
    /** BPAAS Multi-Tennant UserID */
    userID: string;
    /** BPAAS security token to authenticate the user making the request. */
    bPAASToken?: string | undefined;
    /** BPAAS roles of the user making the request. */
    bPAASRoles?: string | undefined;
}

/** An api to return all blocks in a blockchain ledger. */
export class GetAllBlockByBlockchainLedgerIDDTO implements IGetAllBlockByBlockchainLedgerIDDTO {
    /** BPAAS Multi-Tennant ID */
    tenantID!: string;
    /** BPAAS UserID */
    userID!: string;
    /** BPAAS RequestingUserID */
    requestingUserID!: string;
    /** BPAAS LedgerName */
    ledgerName!: string;
    /** BPAAS hash of the proof proving that we have rights to the parent blockchain data we are attempting to update. */
    blockchainProofHash!: string;
    /** BPAAS security token to authenticate the user making the request. */
    bPAASToken?: string | undefined;
    /** BPAAS roles of the user making the request. */
    bPAASRoles?: string | undefined;

    constructor(data?: IGetAllBlockByBlockchainLedgerIDDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.tenantID = _data["TenantID"];
            this.userID = _data["UserID"];
            this.requestingUserID = _data["RequestingUserID"];
            this.ledgerName = _data["LedgerName"];
            this.blockchainProofHash = _data["BlockchainProofHash"];
            this.bPAASToken = _data["BPAASToken"];
            this.bPAASRoles = _data["BPAASRoles"];
        }
    }

    static fromJS(data: any, _mappings?: any): GetAllBlockByBlockchainLedgerIDDTO {
        data = typeof data === 'object' ? data : {};
        return createInstance<GetAllBlockByBlockchainLedgerIDDTO>(data, _mappings, GetAllBlockByBlockchainLedgerIDDTO);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["TenantID"] = this.tenantID;
        data["UserID"] = this.userID;
        data["RequestingUserID"] = this.requestingUserID;
        data["LedgerName"] = this.ledgerName;
        data["BlockchainProofHash"] = this.blockchainProofHash;
        data["BPAASToken"] = this.bPAASToken;
        data["BPAASRoles"] = this.bPAASRoles;
        return data;
    }
}

/** An api to return all blocks in a blockchain ledger. */
export interface IGetAllBlockByBlockchainLedgerIDDTO {
    /** BPAAS Multi-Tennant ID */
    tenantID: string;
    /** BPAAS UserID */
    userID: string;
    /** BPAAS RequestingUserID */
    requestingUserID: string;
    /** BPAAS LedgerName */
    ledgerName: string;
    /** BPAAS hash of the proof proving that we have rights to the parent blockchain data we are attempting to update. */
    blockchainProofHash: string;
    /** BPAAS security token to authenticate the user making the request. */
    bPAASToken?: string | undefined;
    /** BPAAS roles of the user making the request. */
    bPAASRoles?: string | undefined;
}

/** An api to get all transactions for a BPAAS tenant. */
export class GetTransactionStatsByTenantIDDTO implements IGetTransactionStatsByTenantIDDTO {
    /** BPAAS Multi-Tennant ID */
    tenantID!: string;
    /** BPAAS UserID */
    userID!: string;
    /** BPAAS RequestingUserID */
    requestingUserID!: string;
    /** BPAAS Transaction StartDate */
    startDate!: any;
    /** BPAAS Transaction EndDate */
    endDate!: any;
    /** BPAAS security token to authenticate the user making the request. */
    bPAASToken?: string | undefined;
    /** BPAAS roles of the user making the request. */
    bPAASRoles?: string | undefined;

    constructor(data?: IGetTransactionStatsByTenantIDDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.tenantID = _data["TenantID"];
            this.userID = _data["UserID"];
            this.requestingUserID = _data["RequestingUserID"];
            this.startDate = _data["StartDate"] ? new Date(_data["StartDate"].toString()) : <any>undefined;
            this.endDate = _data["EndDate"] ? new Date(_data["EndDate"].toString()) : <any>undefined;
            this.bPAASToken = _data["BPAASToken"];
            this.bPAASRoles = _data["BPAASRoles"];
        }
    }

    static fromJS(data: any, _mappings?: any): GetTransactionStatsByTenantIDDTO {
        data = typeof data === 'object' ? data : {};
        return createInstance<GetTransactionStatsByTenantIDDTO>(data, _mappings, GetTransactionStatsByTenantIDDTO);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["TenantID"] = this.tenantID;
        data["UserID"] = this.userID;
        data["RequestingUserID"] = this.requestingUserID;
        data["StartDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["EndDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["BPAASToken"] = this.bPAASToken;
        data["BPAASRoles"] = this.bPAASRoles;
        return data;
    }
}

/** An api to get all transactions for a BPAAS tenant. */
export interface IGetTransactionStatsByTenantIDDTO {
    /** BPAAS Multi-Tennant ID */
    tenantID: string;
    /** BPAAS UserID */
    userID: string;
    /** BPAAS RequestingUserID */
    requestingUserID: string;
    /** BPAAS Transaction StartDate */
    startDate: any;
    /** BPAAS Transaction EndDate */
    endDate: any;
    /** BPAAS security token to authenticate the user making the request. */
    bPAASToken?: string | undefined;
    /** BPAAS roles of the user making the request. */
    bPAASRoles?: string | undefined;
}

/** An api to download data from a specific block in a blockchain ledger for a BPAAS tenant. */
export class DownloadBlockDataDTO implements IDownloadBlockDataDTO {
    /** BPAAS Multi-Tennant ID */
    tenantID!: string;
    /** BPAAS UserID */
    userID!: string;
    /** BPAAS RequestingUserID */
    requestingUserID!: string;
    /** BPAAS LedgerName */
    ledgerName!: string;
    /** BPAAS Block name */
    blockName!: string;
    /** BPAAS hash of the proof proving that we have rights to the block data we are attempting to update. */
    blockProofHash!: string;
    /** BPAAS hash of the proof proving that we have rights to the parent blockchain data we are attempting to update. */
    blockchainProofHash!: string;
    blockFilter?: string[] | undefined;
    /** BPAAS security token to authenticate the user making the request. */
    bPAASToken?: string | undefined;
    /** BPAAS roles of the user making the request. */
    bPAASRoles?: string | undefined;

    constructor(data?: IDownloadBlockDataDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.tenantID = _data["TenantID"];
            this.userID = _data["UserID"];
            this.requestingUserID = _data["RequestingUserID"];
            this.ledgerName = _data["LedgerName"];
            this.blockName = _data["BlockName"];
            this.blockProofHash = _data["BlockProofHash"];
            this.blockchainProofHash = _data["BlockchainProofHash"];
            if (Array.isArray(_data["BlockFilter"])) {
                this.blockFilter = [] as any;
                for (let item of _data["BlockFilter"])
                    this.blockFilter!.push(item);
            }
            this.bPAASToken = _data["BPAASToken"];
            this.bPAASRoles = _data["BPAASRoles"];
        }
    }

    static fromJS(data: any, _mappings?: any): DownloadBlockDataDTO {
        data = typeof data === 'object' ? data : {};
        return createInstance<DownloadBlockDataDTO>(data, _mappings, DownloadBlockDataDTO);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["TenantID"] = this.tenantID;
        data["UserID"] = this.userID;
        data["RequestingUserID"] = this.requestingUserID;
        data["LedgerName"] = this.ledgerName;
        data["BlockName"] = this.blockName;
        data["BlockProofHash"] = this.blockProofHash;
        data["BlockchainProofHash"] = this.blockchainProofHash;
        if (Array.isArray(this.blockFilter)) {
            data["BlockFilter"] = [];
            for (let item of this.blockFilter)
                data["BlockFilter"].push(item);
        }
        data["BPAASToken"] = this.bPAASToken;
        data["BPAASRoles"] = this.bPAASRoles;
        return data;
    }
}

/** An api to download data from a specific block in a blockchain ledger for a BPAAS tenant. */
export interface IDownloadBlockDataDTO {
    /** BPAAS Multi-Tennant ID */
    tenantID: string;
    /** BPAAS UserID */
    userID: string;
    /** BPAAS RequestingUserID */
    requestingUserID: string;
    /** BPAAS LedgerName */
    ledgerName: string;
    /** BPAAS Block name */
    blockName: string;
    /** BPAAS hash of the proof proving that we have rights to the block data we are attempting to update. */
    blockProofHash: string;
    /** BPAAS hash of the proof proving that we have rights to the parent blockchain data we are attempting to update. */
    blockchainProofHash: string;
    blockFilter?: string[] | undefined;
    /** BPAAS security token to authenticate the user making the request. */
    bPAASToken?: string | undefined;
    /** BPAAS roles of the user making the request. */
    bPAASRoles?: string | undefined;
}

/** An api to download filtered data from a specific block in a blockchain ledger for a BPAAS tenant. */
export class DownloadFilteredBlockDataDTO implements IDownloadFilteredBlockDataDTO {
    /** BPAAS Multi-Tennant ID */
    tenantID!: string;
    /** BPAAS UserID */
    userID!: string;
    /** BPAAS RequestingUserID */
    requestingUserID!: string;
    /** BPAAS LedgerName */
    ledgerName!: string;
    blockProofHash?: string | undefined;
    /** BPAAS hash of the proof proving that we have rights to the parent blockchain data we are attempting to update. */
    blockchainProofHash!: string;
    /** BPAAS block filters applied to the data payload in a block. */
    blockFilter?: any | undefined;
    /** BPAAS security token to authenticate the user making the request. */
    bPAASToken?: string | undefined;
    /** BPAAS roles of the user making the request. */
    bPAASRoles?: string | undefined;

    constructor(data?: IDownloadFilteredBlockDataDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.tenantID = _data["TenantID"];
            this.userID = _data["UserID"];
            this.requestingUserID = _data["RequestingUserID"];
            this.ledgerName = _data["LedgerName"];
            this.blockProofHash = _data["BlockProofHash"];
            this.blockchainProofHash = _data["BlockchainProofHash"];
            this.blockFilter = _data["BlockFilter"];
            this.bPAASToken = _data["BPAASToken"];
            this.bPAASRoles = _data["BPAASRoles"];
        }
    }

    static fromJS(data: any, _mappings?: any): DownloadFilteredBlockDataDTO {
        data = typeof data === 'object' ? data : {};
        return createInstance<DownloadFilteredBlockDataDTO>(data, _mappings, DownloadFilteredBlockDataDTO);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["TenantID"] = this.tenantID;
        data["UserID"] = this.userID;
        data["RequestingUserID"] = this.requestingUserID;
        data["LedgerName"] = this.ledgerName;
        data["BlockProofHash"] = this.blockProofHash;
        data["BlockchainProofHash"] = this.blockchainProofHash;
        data["BlockFilter"] = this.blockFilter;
        data["BPAASToken"] = this.bPAASToken;
        data["BPAASRoles"] = this.bPAASRoles;
        return data;
    }
}

/** An api to download filtered data from a specific block in a blockchain ledger for a BPAAS tenant. */
export interface IDownloadFilteredBlockDataDTO {
    /** BPAAS Multi-Tennant ID */
    tenantID: string;
    /** BPAAS UserID */
    userID: string;
    /** BPAAS RequestingUserID */
    requestingUserID: string;
    /** BPAAS LedgerName */
    ledgerName: string;
    blockProofHash?: string | undefined;
    /** BPAAS hash of the proof proving that we have rights to the parent blockchain data we are attempting to update. */
    blockchainProofHash: string;
    /** BPAAS block filters applied to the data payload in a block. */
    blockFilter?: any | undefined;
    /** BPAAS security token to authenticate the user making the request. */
    bPAASToken?: string | undefined;
    /** BPAAS roles of the user making the request. */
    bPAASRoles?: string | undefined;
}

/** AssignRoles */
export class AssignRoles implements IAssignRoles {
    userName?: string | undefined;
    permissions?: string[] | undefined;
    roles?: string[] | undefined;
    meta?: Dictionary_String_String_ | undefined;

    constructor(data?: IAssignRoles) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.userName = _data["UserName"];
            if (Array.isArray(_data["Permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["Permissions"])
                    this.permissions!.push(item);
            }
            if (Array.isArray(_data["Roles"])) {
                this.roles = [] as any;
                for (let item of _data["Roles"])
                    this.roles!.push(item);
            }
            this.meta = _data["Meta"] ? Dictionary_String_String_.fromJS(_data["Meta"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): AssignRoles {
        data = typeof data === 'object' ? data : {};
        return createInstance<AssignRoles>(data, _mappings, AssignRoles);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UserName"] = this.userName;
        if (Array.isArray(this.permissions)) {
            data["Permissions"] = [];
            for (let item of this.permissions)
                data["Permissions"].push(item);
        }
        if (Array.isArray(this.roles)) {
            data["Roles"] = [];
            for (let item of this.roles)
                data["Roles"].push(item);
        }
        data["Meta"] = this.meta ? this.meta.toJSON() : <any>undefined;
        return data;
    }
}

/** AssignRoles */
export interface IAssignRoles {
    userName?: string | undefined;
    permissions?: string[] | undefined;
    roles?: string[] | undefined;
    meta?: Dictionary_String_String_ | undefined;
}

/** Dictionary<String,String> */
export class Dictionary_String_String_ implements IDictionary_String_String_ {

    [key: string]: string | any;

    constructor(data?: IDictionary_String_String_) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
        }
    }

    static fromJS(data: any, _mappings?: any): Dictionary_String_String_ {
        data = typeof data === 'object' ? data : {};
        return createInstance<Dictionary_String_String_>(data, _mappings, Dictionary_String_String_);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        return data;
    }
}

/** Dictionary<String,String> */
export interface IDictionary_String_String_ {

    [key: string]: string | any;
}

/** UnAssignRoles */
export class UnAssignRoles implements IUnAssignRoles {
    userName?: string | undefined;
    permissions?: string[] | undefined;
    roles?: string[] | undefined;
    meta?: Dictionary_String_String_ | undefined;

    constructor(data?: IUnAssignRoles) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.userName = _data["UserName"];
            if (Array.isArray(_data["Permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["Permissions"])
                    this.permissions!.push(item);
            }
            if (Array.isArray(_data["Roles"])) {
                this.roles = [] as any;
                for (let item of _data["Roles"])
                    this.roles!.push(item);
            }
            this.meta = _data["Meta"] ? Dictionary_String_String_.fromJS(_data["Meta"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): UnAssignRoles {
        data = typeof data === 'object' ? data : {};
        return createInstance<UnAssignRoles>(data, _mappings, UnAssignRoles);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UserName"] = this.userName;
        if (Array.isArray(this.permissions)) {
            data["Permissions"] = [];
            for (let item of this.permissions)
                data["Permissions"].push(item);
        }
        if (Array.isArray(this.roles)) {
            data["Roles"] = [];
            for (let item of this.roles)
                data["Roles"].push(item);
        }
        data["Meta"] = this.meta ? this.meta.toJSON() : <any>undefined;
        return data;
    }
}

/** UnAssignRoles */
export interface IUnAssignRoles {
    userName?: string | undefined;
    permissions?: string[] | undefined;
    roles?: string[] | undefined;
    meta?: Dictionary_String_String_ | undefined;
}

/** Register */
export class Register implements IRegister {
    userName?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    displayName?: string | undefined;
    email?: string | undefined;
    password?: string | undefined;
    confirmPassword?: string | undefined;
    autoLogin?: boolean | undefined;
    continue?: string | undefined;
    errorView?: string | undefined;
    meta?: Dictionary_String_String_ | undefined;

    constructor(data?: IRegister) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.userName = _data["UserName"];
            this.firstName = _data["FirstName"];
            this.lastName = _data["LastName"];
            this.displayName = _data["DisplayName"];
            this.email = _data["Email"];
            this.password = _data["Password"];
            this.confirmPassword = _data["ConfirmPassword"];
            this.autoLogin = _data["AutoLogin"];
            this.continue = _data["Continue"];
            this.errorView = _data["ErrorView"];
            this.meta = _data["Meta"] ? Dictionary_String_String_.fromJS(_data["Meta"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): Register {
        data = typeof data === 'object' ? data : {};
        return createInstance<Register>(data, _mappings, Register);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UserName"] = this.userName;
        data["FirstName"] = this.firstName;
        data["LastName"] = this.lastName;
        data["DisplayName"] = this.displayName;
        data["Email"] = this.email;
        data["Password"] = this.password;
        data["ConfirmPassword"] = this.confirmPassword;
        data["AutoLogin"] = this.autoLogin;
        data["Continue"] = this.continue;
        data["ErrorView"] = this.errorView;
        data["Meta"] = this.meta ? this.meta.toJSON() : <any>undefined;
        return data;
    }
}

/** Register */
export interface IRegister {
    userName?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    displayName?: string | undefined;
    email?: string | undefined;
    password?: string | undefined;
    confirmPassword?: string | undefined;
    autoLogin?: boolean | undefined;
    continue?: string | undefined;
    errorView?: string | undefined;
    meta?: Dictionary_String_String_ | undefined;
}

/** GetApiKeys */
export class GetApiKeys implements IGetApiKeys {
    environment?: string | undefined;
    meta?: Dictionary_String_String_ | undefined;

    constructor(data?: IGetApiKeys) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.environment = _data["Environment"];
            this.meta = _data["Meta"] ? Dictionary_String_String_.fromJS(_data["Meta"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): GetApiKeys {
        data = typeof data === 'object' ? data : {};
        return createInstance<GetApiKeys>(data, _mappings, GetApiKeys);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Environment"] = this.environment;
        data["Meta"] = this.meta ? this.meta.toJSON() : <any>undefined;
        return data;
    }
}

/** GetApiKeys */
export interface IGetApiKeys {
    environment?: string | undefined;
    meta?: Dictionary_String_String_ | undefined;
}

/** GetIPAddressInfoResponseDTO */
export class GetIPAddressInfoResponseDTO implements IGetIPAddressInfoResponseDTO {
    eNV_IPADDRESS?: string | undefined;
    iNT_IPADDRESS?: string | undefined;
    eNV_NODE_IPADDRESS?: string | undefined;
    eNV_NODE_PORT?: string | undefined;
    responseTime?: string | undefined;
    bPAASToken?: string | undefined;

    constructor(data?: IGetIPAddressInfoResponseDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.eNV_IPADDRESS = _data["ENV_IPADDRESS"];
            this.iNT_IPADDRESS = _data["INT_IPADDRESS"];
            this.eNV_NODE_IPADDRESS = _data["ENV_NODE_IPADDRESS"];
            this.eNV_NODE_PORT = _data["ENV_NODE_PORT"];
            this.responseTime = _data["ResponseTime"];
            this.bPAASToken = _data["BPAASToken"];
        }
    }

    static fromJS(data: any, _mappings?: any): GetIPAddressInfoResponseDTO {
        data = typeof data === 'object' ? data : {};
        return createInstance<GetIPAddressInfoResponseDTO>(data, _mappings, GetIPAddressInfoResponseDTO);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ENV_IPADDRESS"] = this.eNV_IPADDRESS;
        data["INT_IPADDRESS"] = this.iNT_IPADDRESS;
        data["ENV_NODE_IPADDRESS"] = this.eNV_NODE_IPADDRESS;
        data["ENV_NODE_PORT"] = this.eNV_NODE_PORT;
        data["ResponseTime"] = this.responseTime;
        data["BPAASToken"] = this.bPAASToken;
        return data;
    }
}

/** GetIPAddressInfoResponseDTO */
export interface IGetIPAddressInfoResponseDTO {
    eNV_IPADDRESS?: string | undefined;
    iNT_IPADDRESS?: string | undefined;
    eNV_NODE_IPADDRESS?: string | undefined;
    eNV_NODE_PORT?: string | undefined;
    responseTime?: string | undefined;
    bPAASToken?: string | undefined;
}

/** GrantBlockchainAccessResponseDTO */
export class GrantBlockchainAccessResponseDTO implements IGrantBlockchainAccessResponseDTO {
    tenantID?: string | undefined;
    ledgerName?: string | undefined;
    userID?: string | undefined;
    statusMessage?: string | undefined;
    responseTime?: string | undefined;
    bPAASToken?: string | undefined;

    constructor(data?: IGrantBlockchainAccessResponseDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.tenantID = _data["TenantID"];
            this.ledgerName = _data["LedgerName"];
            this.userID = _data["UserID"];
            this.statusMessage = _data["StatusMessage"];
            this.responseTime = _data["ResponseTime"];
            this.bPAASToken = _data["BPAASToken"];
        }
    }

    static fromJS(data: any, _mappings?: any): GrantBlockchainAccessResponseDTO {
        data = typeof data === 'object' ? data : {};
        return createInstance<GrantBlockchainAccessResponseDTO>(data, _mappings, GrantBlockchainAccessResponseDTO);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["TenantID"] = this.tenantID;
        data["LedgerName"] = this.ledgerName;
        data["UserID"] = this.userID;
        data["StatusMessage"] = this.statusMessage;
        data["ResponseTime"] = this.responseTime;
        data["BPAASToken"] = this.bPAASToken;
        return data;
    }
}

/** GrantBlockchainAccessResponseDTO */
export interface IGrantBlockchainAccessResponseDTO {
    tenantID?: string | undefined;
    ledgerName?: string | undefined;
    userID?: string | undefined;
    statusMessage?: string | undefined;
    responseTime?: string | undefined;
    bPAASToken?: string | undefined;
}

/** GetAuthorizedUsersResponseDTOs */
export class GetAuthorizedUsersResponseDTOs implements IGetAuthorizedUsersResponseDTOs {
    tenantID?: string | undefined;
    ledgerName?: string | undefined;
    userID?: string | undefined;
    authorizedUserIDs?: string[] | undefined;
    statusMessage?: string | undefined;
    responseTime?: string | undefined;
    bPAASToken?: string | undefined;

    constructor(data?: IGetAuthorizedUsersResponseDTOs) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.tenantID = _data["TenantID"];
            this.ledgerName = _data["LedgerName"];
            this.userID = _data["UserID"];
            if (Array.isArray(_data["AuthorizedUserIDs"])) {
                this.authorizedUserIDs = [] as any;
                for (let item of _data["AuthorizedUserIDs"])
                    this.authorizedUserIDs!.push(item);
            }
            this.statusMessage = _data["StatusMessage"];
            this.responseTime = _data["ResponseTime"];
            this.bPAASToken = _data["BPAASToken"];
        }
    }

    static fromJS(data: any, _mappings?: any): GetAuthorizedUsersResponseDTOs {
        data = typeof data === 'object' ? data : {};
        return createInstance<GetAuthorizedUsersResponseDTOs>(data, _mappings, GetAuthorizedUsersResponseDTOs);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["TenantID"] = this.tenantID;
        data["LedgerName"] = this.ledgerName;
        data["UserID"] = this.userID;
        if (Array.isArray(this.authorizedUserIDs)) {
            data["AuthorizedUserIDs"] = [];
            for (let item of this.authorizedUserIDs)
                data["AuthorizedUserIDs"].push(item);
        }
        data["StatusMessage"] = this.statusMessage;
        data["ResponseTime"] = this.responseTime;
        data["BPAASToken"] = this.bPAASToken;
        return data;
    }
}

/** GetAuthorizedUsersResponseDTOs */
export interface IGetAuthorizedUsersResponseDTOs {
    tenantID?: string | undefined;
    ledgerName?: string | undefined;
    userID?: string | undefined;
    authorizedUserIDs?: string[] | undefined;
    statusMessage?: string | undefined;
    responseTime?: string | undefined;
    bPAASToken?: string | undefined;
}

/** RevokeBlockchainAccessResponseDTOcs */
export class RevokeBlockchainAccessResponseDTOcs implements IRevokeBlockchainAccessResponseDTOcs {
    tenantID?: string | undefined;
    ledgerName?: string | undefined;
    userID?: string | undefined;
    statusMessage?: string | undefined;
    responseTime?: string | undefined;
    bPAASToken?: string | undefined;

    constructor(data?: IRevokeBlockchainAccessResponseDTOcs) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.tenantID = _data["TenantID"];
            this.ledgerName = _data["LedgerName"];
            this.userID = _data["UserID"];
            this.statusMessage = _data["StatusMessage"];
            this.responseTime = _data["ResponseTime"];
            this.bPAASToken = _data["BPAASToken"];
        }
    }

    static fromJS(data: any, _mappings?: any): RevokeBlockchainAccessResponseDTOcs {
        data = typeof data === 'object' ? data : {};
        return createInstance<RevokeBlockchainAccessResponseDTOcs>(data, _mappings, RevokeBlockchainAccessResponseDTOcs);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["TenantID"] = this.tenantID;
        data["LedgerName"] = this.ledgerName;
        data["UserID"] = this.userID;
        data["StatusMessage"] = this.statusMessage;
        data["ResponseTime"] = this.responseTime;
        data["BPAASToken"] = this.bPAASToken;
        return data;
    }
}

/** RevokeBlockchainAccessResponseDTOcs */
export interface IRevokeBlockchainAccessResponseDTOcs {
    tenantID?: string | undefined;
    ledgerName?: string | undefined;
    userID?: string | undefined;
    statusMessage?: string | undefined;
    responseTime?: string | undefined;
    bPAASToken?: string | undefined;
}

/** CreateBlockchainLedgerResponseDTO */
export class CreateBlockchainLedgerResponseDTO implements ICreateBlockchainLedgerResponseDTO {
    tenantID?: string | undefined;
    userID?: string | undefined;
    ledgerName?: string | undefined;
    blockchainProofHash?: string | undefined;
    statusMessage?: string | undefined;
    createdDate?: Date | undefined;
    updateddDate?: Date | undefined;
    responseTime?: string | undefined;
    bPAASToken?: string | undefined;

    constructor(data?: ICreateBlockchainLedgerResponseDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.tenantID = _data["TenantID"];
            this.userID = _data["UserID"];
            this.ledgerName = _data["LedgerName"];
            this.blockchainProofHash = _data["BlockchainProofHash"];
            this.statusMessage = _data["StatusMessage"];
            this.createdDate = _data["CreatedDate"] ? new Date(_data["CreatedDate"].toString()) : <any>undefined;
            this.updateddDate = _data["UpdateddDate"] ? new Date(_data["UpdateddDate"].toString()) : <any>undefined;
            this.responseTime = _data["ResponseTime"];
            this.bPAASToken = _data["BPAASToken"];
        }
    }

    static fromJS(data: any, _mappings?: any): CreateBlockchainLedgerResponseDTO {
        data = typeof data === 'object' ? data : {};
        return createInstance<CreateBlockchainLedgerResponseDTO>(data, _mappings, CreateBlockchainLedgerResponseDTO);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["TenantID"] = this.tenantID;
        data["UserID"] = this.userID;
        data["LedgerName"] = this.ledgerName;
        data["BlockchainProofHash"] = this.blockchainProofHash;
        data["StatusMessage"] = this.statusMessage;
        data["CreatedDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
        data["UpdateddDate"] = this.updateddDate ? this.updateddDate.toISOString() : <any>undefined;
        data["ResponseTime"] = this.responseTime;
        data["BPAASToken"] = this.bPAASToken;
        return data;
    }
}

/** CreateBlockchainLedgerResponseDTO */
export interface ICreateBlockchainLedgerResponseDTO {
    tenantID?: string | undefined;
    userID?: string | undefined;
    ledgerName?: string | undefined;
    blockchainProofHash?: string | undefined;
    statusMessage?: string | undefined;
    createdDate?: Date | undefined;
    updateddDate?: Date | undefined;
    responseTime?: string | undefined;
    bPAASToken?: string | undefined;
}

/** AddToBlockchainLedgerResponseDTO */
export class AddToBlockchainLedgerResponseDTO implements IAddToBlockchainLedgerResponseDTO {
    tenantID?: string | undefined;
    userID?: string | undefined;
    ledgerName?: string | undefined;
    blockName?: string | undefined;
    statusMessage?: string | undefined;
    blockProofHash?: string | undefined;
    blockFullPath?: string | undefined;
    blockType?: string | undefined;
    isSmartContract?: boolean | undefined;
    isFile?: boolean | undefined;
    fileExtension?: string | undefined;
    updatedDate?: Date | undefined;
    responseTime?: string | undefined;
    bPAASToken?: string | undefined;
    isSuccess: boolean = false;
    errorMessage: string;
    constructor(data?: IAddToBlockchainLedgerResponseDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.tenantID = _data["TenantID"];
            this.userID = _data["UserID"];
            this.ledgerName = _data["LedgerName"];
            this.blockName = _data["BlockName"];
            this.statusMessage = _data["StatusMessage"];
            this.blockProofHash = _data["BlockProofHash"];
            this.blockFullPath = _data["BlockFullPath"];
            this.blockType = _data["BlockType"];
            this.isSmartContract = _data["IsSmartContract"];
            this.isFile = _data["IsFile"];
            this.fileExtension = _data["FileExtension"];
            this.updatedDate = _data["UpdatedDate"] ? new Date(_data["UpdatedDate"].toString()) : <any>undefined;
            this.responseTime = _data["ResponseTime"];
            this.bPAASToken = _data["BPAASToken"];
        }
    }

    static fromJS(data: any, _mappings?: any): AddToBlockchainLedgerResponseDTO {
        data = typeof data === 'object' ? data : {};
        return createInstance<AddToBlockchainLedgerResponseDTO>(data, _mappings, AddToBlockchainLedgerResponseDTO);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["TenantID"] = this.tenantID;
        data["UserID"] = this.userID;
        data["LedgerName"] = this.ledgerName;
        data["BlockName"] = this.blockName;
        data["StatusMessage"] = this.statusMessage;
        data["BlockProofHash"] = this.blockProofHash;
        data["BlockFullPath"] = this.blockFullPath;
        data["BlockType"] = this.blockType;
        data["IsSmartContract"] = this.isSmartContract;
        data["IsFile"] = this.isFile;
        data["FileExtension"] = this.fileExtension;
        data["UpdatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
        data["ResponseTime"] = this.responseTime;
        data["BPAASToken"] = this.bPAASToken;
        return data;
    }
}

/** AddToBlockchainLedgerResponseDTO */
export interface IAddToBlockchainLedgerResponseDTO {
    tenantID?: string | undefined;
    userID?: string | undefined;
    ledgerName?: string | undefined;
    blockName?: string | undefined;
    statusMessage?: string | undefined;
    blockProofHash?: string | undefined;
    blockFullPath?: string | undefined;
    blockType?: string | undefined;
    isSmartContract?: boolean | undefined;
    isFile?: boolean | undefined;
    fileExtension?: string | undefined;
    updatedDate?: Date | undefined;
    responseTime?: string | undefined;
    bPAASToken?: string | undefined;
}

/** DeleteFromBlockchainLedgerResponseDTO */
export class DeleteFromBlockchainLedgerResponseDTO implements IDeleteFromBlockchainLedgerResponseDTO {
    tenantID?: string | undefined;
    ledgerName?: string | undefined;
    userID?: string | undefined;
    blockName?: string | undefined;
    statusMessage?: string | undefined;
    responseTime?: string | undefined;
    bPAASToken?: string | undefined;

    constructor(data?: IDeleteFromBlockchainLedgerResponseDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.tenantID = _data["TenantID"];
            this.ledgerName = _data["LedgerName"];
            this.userID = _data["UserID"];
            this.blockName = _data["BlockName"];
            this.statusMessage = _data["StatusMessage"];
            this.responseTime = _data["ResponseTime"];
            this.bPAASToken = _data["BPAASToken"];
        }
    }

    static fromJS(data: any, _mappings?: any): DeleteFromBlockchainLedgerResponseDTO {
        data = typeof data === 'object' ? data : {};
        return createInstance<DeleteFromBlockchainLedgerResponseDTO>(data, _mappings, DeleteFromBlockchainLedgerResponseDTO);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["TenantID"] = this.tenantID;
        data["LedgerName"] = this.ledgerName;
        data["UserID"] = this.userID;
        data["BlockName"] = this.blockName;
        data["StatusMessage"] = this.statusMessage;
        data["ResponseTime"] = this.responseTime;
        data["BPAASToken"] = this.bPAASToken;
        return data;
    }
}

/** DeleteFromBlockchainLedgerResponseDTO */
export interface IDeleteFromBlockchainLedgerResponseDTO {
    tenantID?: string | undefined;
    ledgerName?: string | undefined;
    userID?: string | undefined;
    blockName?: string | undefined;
    statusMessage?: string | undefined;
    responseTime?: string | undefined;
    bPAASToken?: string | undefined;
}

/** LockBlockchainLedgerResponseDTO */
export class LockBlockchainLedgerResponseDTO implements ILockBlockchainLedgerResponseDTO {
    tenantID?: string | undefined;
    ledgerName?: string | undefined;
    userID?: string | undefined;
    statusMessage?: string | undefined;
    responseTime?: string | undefined;
    bPAASToken?: string | undefined;

    constructor(data?: ILockBlockchainLedgerResponseDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.tenantID = _data["TenantID"];
            this.ledgerName = _data["LedgerName"];
            this.userID = _data["UserID"];
            this.statusMessage = _data["StatusMessage"];
            this.responseTime = _data["ResponseTime"];
            this.bPAASToken = _data["BPAASToken"];
        }
    }

    static fromJS(data: any, _mappings?: any): LockBlockchainLedgerResponseDTO {
        data = typeof data === 'object' ? data : {};
        return createInstance<LockBlockchainLedgerResponseDTO>(data, _mappings, LockBlockchainLedgerResponseDTO);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["TenantID"] = this.tenantID;
        data["LedgerName"] = this.ledgerName;
        data["UserID"] = this.userID;
        data["StatusMessage"] = this.statusMessage;
        data["ResponseTime"] = this.responseTime;
        data["BPAASToken"] = this.bPAASToken;
        return data;
    }
}

/** LockBlockchainLedgerResponseDTO */
export interface ILockBlockchainLedgerResponseDTO {
    tenantID?: string | undefined;
    ledgerName?: string | undefined;
    userID?: string | undefined;
    statusMessage?: string | undefined;
    responseTime?: string | undefined;
    bPAASToken?: string | undefined;
}

/** UnLockBlockchainLedgerResponseDTO */
export class UnLockBlockchainLedgerResponseDTO implements IUnLockBlockchainLedgerResponseDTO {
    tenantID?: string | undefined;
    ledgerName?: string | undefined;
    userID?: string | undefined;
    statusMessage?: string | undefined;
    responseTime?: string | undefined;
    bPAASToken?: string | undefined;

    constructor(data?: IUnLockBlockchainLedgerResponseDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.tenantID = _data["TenantID"];
            this.ledgerName = _data["LedgerName"];
            this.userID = _data["UserID"];
            this.statusMessage = _data["StatusMessage"];
            this.responseTime = _data["ResponseTime"];
            this.bPAASToken = _data["BPAASToken"];
        }
    }

    static fromJS(data: any, _mappings?: any): UnLockBlockchainLedgerResponseDTO {
        data = typeof data === 'object' ? data : {};
        return createInstance<UnLockBlockchainLedgerResponseDTO>(data, _mappings, UnLockBlockchainLedgerResponseDTO);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["TenantID"] = this.tenantID;
        data["LedgerName"] = this.ledgerName;
        data["UserID"] = this.userID;
        data["StatusMessage"] = this.statusMessage;
        data["ResponseTime"] = this.responseTime;
        data["BPAASToken"] = this.bPAASToken;
        return data;
    }
}

/** UnLockBlockchainLedgerResponseDTO */
export interface IUnLockBlockchainLedgerResponseDTO {
    tenantID?: string | undefined;
    ledgerName?: string | undefined;
    userID?: string | undefined;
    statusMessage?: string | undefined;
    responseTime?: string | undefined;
    bPAASToken?: string | undefined;
}

/** GetTransactionStatsByTenantIDResponseDTO */
export class GetTransactionStatsByTenantIDResponseDTO implements IGetTransactionStatsByTenantIDResponseDTO {
    transactions?: TenantTransactions[] | undefined;
    statusMessage?: string | undefined;
    responseTime?: string | undefined;
    bPAASToken?: string | undefined;

    constructor(data?: IGetTransactionStatsByTenantIDResponseDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["Transactions"])) {
                this.transactions = [] as any;
                for (let item of _data["Transactions"])
                    this.transactions!.push(TenantTransactions.fromJS(item, _mappings));
            }
            this.statusMessage = _data["StatusMessage"];
            this.responseTime = _data["ResponseTime"];
            this.bPAASToken = _data["BPAASToken"];
        }
    }

    static fromJS(data: any, _mappings?: any): GetTransactionStatsByTenantIDResponseDTO {
        data = typeof data === 'object' ? data : {};
        return createInstance<GetTransactionStatsByTenantIDResponseDTO>(data, _mappings, GetTransactionStatsByTenantIDResponseDTO);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.transactions)) {
            data["Transactions"] = [];
            for (let item of this.transactions)
                data["Transactions"].push(item.toJSON());
        }
        data["StatusMessage"] = this.statusMessage;
        data["ResponseTime"] = this.responseTime;
        data["BPAASToken"] = this.bPAASToken;
        return data;
    }
}

/** GetTransactionStatsByTenantIDResponseDTO */
export interface IGetTransactionStatsByTenantIDResponseDTO {
    transactions?: TenantTransactions[] | undefined;
    statusMessage?: string | undefined;
    responseTime?: string | undefined;
    bPAASToken?: string | undefined;
}

/** TenantTransactions */
export class TenantTransactions implements ITenantTransactions {
    tenantID?: string | undefined;
    transactionDate?: Date | undefined;
    transactionType?: string | undefined;
    transactionUserID?: string | undefined;
    ledgerName?: string | undefined;
    blockName?: string | undefined;
    ledgerDescription?: string | undefined;
    ledgerBlockchainProofHashCode?: string | undefined;

    constructor(data?: ITenantTransactions) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.tenantID = _data["TenantID"];
            this.transactionDate = _data["TransactionDate"] ? new Date(_data["TransactionDate"].toString()) : <any>undefined;
            this.transactionType = _data["TransactionType"];
            this.transactionUserID = _data["TransactionUserID"];
            this.ledgerName = _data["LedgerName"];
            this.blockName = _data["BlockName"];
            this.ledgerDescription = _data["LedgerDescription"];
            this.ledgerBlockchainProofHashCode = _data["LedgerBlockchainProofHashCode"];
        }
    }

    static fromJS(data: any, _mappings?: any): TenantTransactions {
        data = typeof data === 'object' ? data : {};
        return createInstance<TenantTransactions>(data, _mappings, TenantTransactions);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["TenantID"] = this.tenantID;
        data["TransactionDate"] = this.transactionDate ? this.transactionDate.toISOString() : <any>undefined;
        data["TransactionType"] = this.transactionType;
        data["TransactionUserID"] = this.transactionUserID;
        data["LedgerName"] = this.ledgerName;
        data["BlockName"] = this.blockName;
        data["LedgerDescription"] = this.ledgerDescription;
        data["LedgerBlockchainProofHashCode"] = this.ledgerBlockchainProofHashCode;
        return data;
    }
}

/** TenantTransactions */
export interface ITenantTransactions {
    tenantID?: string | undefined;
    transactionDate?: Date | undefined;
    transactionType?: string | undefined;
    transactionUserID?: string | undefined;
    ledgerName?: string | undefined;
    blockName?: string | undefined;
    ledgerDescription?: string | undefined;
    ledgerBlockchainProofHashCode?: string | undefined;
}

/** AssignRolesResponse */
export class AssignRolesResponse implements IAssignRolesResponse {
    allRoles?: string[] | undefined;
    allPermissions?: string[] | undefined;
    meta?: Dictionary_String_String_ | undefined;
    responseStatus?: ResponseStatus | undefined;

    constructor(data?: IAssignRolesResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["AllRoles"])) {
                this.allRoles = [] as any;
                for (let item of _data["AllRoles"])
                    this.allRoles!.push(item);
            }
            if (Array.isArray(_data["AllPermissions"])) {
                this.allPermissions = [] as any;
                for (let item of _data["AllPermissions"])
                    this.allPermissions!.push(item);
            }
            this.meta = _data["Meta"] ? Dictionary_String_String_.fromJS(_data["Meta"], _mappings) : <any>undefined;
            this.responseStatus = _data["ResponseStatus"] ? ResponseStatus.fromJS(_data["ResponseStatus"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): AssignRolesResponse {
        data = typeof data === 'object' ? data : {};
        return createInstance<AssignRolesResponse>(data, _mappings, AssignRolesResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.allRoles)) {
            data["AllRoles"] = [];
            for (let item of this.allRoles)
                data["AllRoles"].push(item);
        }
        if (Array.isArray(this.allPermissions)) {
            data["AllPermissions"] = [];
            for (let item of this.allPermissions)
                data["AllPermissions"].push(item);
        }
        data["Meta"] = this.meta ? this.meta.toJSON() : <any>undefined;
        data["ResponseStatus"] = this.responseStatus ? this.responseStatus.toJSON() : <any>undefined;
        return data;
    }
}

/** AssignRolesResponse */
export interface IAssignRolesResponse {
    allRoles?: string[] | undefined;
    allPermissions?: string[] | undefined;
    meta?: Dictionary_String_String_ | undefined;
    responseStatus?: ResponseStatus | undefined;
}

/** ResponseStatus */
export class ResponseStatus implements IResponseStatus {
    errorCode?: string | undefined;
    message?: string | undefined;
    stackTrace?: string | undefined;
    errors?: ResponseError[] | undefined;
    meta?: Dictionary_String_String_ | undefined;

    constructor(data?: IResponseStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.errorCode = _data["ErrorCode"];
            this.message = _data["Message"];
            this.stackTrace = _data["StackTrace"];
            if (Array.isArray(_data["Errors"])) {
                this.errors = [] as any;
                for (let item of _data["Errors"])
                    this.errors!.push(ResponseError.fromJS(item, _mappings));
            }
            this.meta = _data["Meta"] ? Dictionary_String_String_.fromJS(_data["Meta"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): ResponseStatus {
        data = typeof data === 'object' ? data : {};
        return createInstance<ResponseStatus>(data, _mappings, ResponseStatus);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ErrorCode"] = this.errorCode;
        data["Message"] = this.message;
        data["StackTrace"] = this.stackTrace;
        if (Array.isArray(this.errors)) {
            data["Errors"] = [];
            for (let item of this.errors)
                data["Errors"].push(item.toJSON());
        }
        data["Meta"] = this.meta ? this.meta.toJSON() : <any>undefined;
        return data;
    }
}

/** ResponseStatus */
export interface IResponseStatus {
    errorCode?: string | undefined;
    message?: string | undefined;
    stackTrace?: string | undefined;
    errors?: ResponseError[] | undefined;
    meta?: Dictionary_String_String_ | undefined;
}

/** ResponseError */
export class ResponseError implements IResponseError {
    errorCode?: string | undefined;
    fieldName?: string | undefined;
    message?: string | undefined;
    meta?: Dictionary_String_String_ | undefined;

    constructor(data?: IResponseError) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.errorCode = _data["ErrorCode"];
            this.fieldName = _data["FieldName"];
            this.message = _data["Message"];
            this.meta = _data["Meta"] ? Dictionary_String_String_.fromJS(_data["Meta"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): ResponseError {
        data = typeof data === 'object' ? data : {};
        return createInstance<ResponseError>(data, _mappings, ResponseError);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ErrorCode"] = this.errorCode;
        data["FieldName"] = this.fieldName;
        data["Message"] = this.message;
        data["Meta"] = this.meta ? this.meta.toJSON() : <any>undefined;
        return data;
    }
}

/** ResponseError */
export interface IResponseError {
    errorCode?: string | undefined;
    fieldName?: string | undefined;
    message?: string | undefined;
    meta?: Dictionary_String_String_ | undefined;
}

/** UnAssignRolesResponse */
export class UnAssignRolesResponse implements IUnAssignRolesResponse {
    allRoles?: string[] | undefined;
    allPermissions?: string[] | undefined;
    meta?: Dictionary_String_String_ | undefined;
    responseStatus?: ResponseStatus | undefined;

    constructor(data?: IUnAssignRolesResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["AllRoles"])) {
                this.allRoles = [] as any;
                for (let item of _data["AllRoles"])
                    this.allRoles!.push(item);
            }
            if (Array.isArray(_data["AllPermissions"])) {
                this.allPermissions = [] as any;
                for (let item of _data["AllPermissions"])
                    this.allPermissions!.push(item);
            }
            this.meta = _data["Meta"] ? Dictionary_String_String_.fromJS(_data["Meta"], _mappings) : <any>undefined;
            this.responseStatus = _data["ResponseStatus"] ? ResponseStatus.fromJS(_data["ResponseStatus"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): UnAssignRolesResponse {
        data = typeof data === 'object' ? data : {};
        return createInstance<UnAssignRolesResponse>(data, _mappings, UnAssignRolesResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.allRoles)) {
            data["AllRoles"] = [];
            for (let item of this.allRoles)
                data["AllRoles"].push(item);
        }
        if (Array.isArray(this.allPermissions)) {
            data["AllPermissions"] = [];
            for (let item of this.allPermissions)
                data["AllPermissions"].push(item);
        }
        data["Meta"] = this.meta ? this.meta.toJSON() : <any>undefined;
        data["ResponseStatus"] = this.responseStatus ? this.responseStatus.toJSON() : <any>undefined;
        return data;
    }
}

/** UnAssignRolesResponse */
export interface IUnAssignRolesResponse {
    allRoles?: string[] | undefined;
    allPermissions?: string[] | undefined;
    meta?: Dictionary_String_String_ | undefined;
    responseStatus?: ResponseStatus | undefined;
}

/** RegisterResponse */
export class RegisterResponse implements IRegisterResponse {
    userId?: string | undefined;
    sessionId?: string | undefined;
    userName?: string | undefined;
    referrerUrl?: string | undefined;
    bearerToken?: string | undefined;
    refreshToken?: string | undefined;
    responseStatus?: ResponseStatus | undefined;
    meta?: Dictionary_String_String_ | undefined;

    constructor(data?: IRegisterResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.userId = _data["UserId"];
            this.sessionId = _data["SessionId"];
            this.userName = _data["UserName"];
            this.referrerUrl = _data["ReferrerUrl"];
            this.bearerToken = _data["BearerToken"];
            this.refreshToken = _data["RefreshToken"];
            this.responseStatus = _data["ResponseStatus"] ? ResponseStatus.fromJS(_data["ResponseStatus"], _mappings) : <any>undefined;
            this.meta = _data["Meta"] ? Dictionary_String_String_.fromJS(_data["Meta"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): RegisterResponse {
        data = typeof data === 'object' ? data : {};
        return createInstance<RegisterResponse>(data, _mappings, RegisterResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UserId"] = this.userId;
        data["SessionId"] = this.sessionId;
        data["UserName"] = this.userName;
        data["ReferrerUrl"] = this.referrerUrl;
        data["BearerToken"] = this.bearerToken;
        data["RefreshToken"] = this.refreshToken;
        data["ResponseStatus"] = this.responseStatus ? this.responseStatus.toJSON() : <any>undefined;
        data["Meta"] = this.meta ? this.meta.toJSON() : <any>undefined;
        return data;
    }
}

/** RegisterResponse */
export interface IRegisterResponse {
    userId?: string | undefined;
    sessionId?: string | undefined;
    userName?: string | undefined;
    referrerUrl?: string | undefined;
    bearerToken?: string | undefined;
    refreshToken?: string | undefined;
    responseStatus?: ResponseStatus | undefined;
    meta?: Dictionary_String_String_ | undefined;
}

/** GetApiKeysResponse */
export class GetApiKeysResponse implements IGetApiKeysResponse {
    results?: UserApiKey[] | undefined;
    meta?: Dictionary_String_String_ | undefined;
    responseStatus?: ResponseStatus | undefined;

    constructor(data?: IGetApiKeysResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            if (Array.isArray(_data["Results"])) {
                this.results = [] as any;
                for (let item of _data["Results"])
                    this.results!.push(UserApiKey.fromJS(item, _mappings));
            }
            this.meta = _data["Meta"] ? Dictionary_String_String_.fromJS(_data["Meta"], _mappings) : <any>undefined;
            this.responseStatus = _data["ResponseStatus"] ? ResponseStatus.fromJS(_data["ResponseStatus"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): GetApiKeysResponse {
        data = typeof data === 'object' ? data : {};
        return createInstance<GetApiKeysResponse>(data, _mappings, GetApiKeysResponse);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.results)) {
            data["Results"] = [];
            for (let item of this.results)
                data["Results"].push(item.toJSON());
        }
        data["Meta"] = this.meta ? this.meta.toJSON() : <any>undefined;
        data["ResponseStatus"] = this.responseStatus ? this.responseStatus.toJSON() : <any>undefined;
        return data;
    }
}

/** GetApiKeysResponse */
export interface IGetApiKeysResponse {
    results?: UserApiKey[] | undefined;
    meta?: Dictionary_String_String_ | undefined;
    responseStatus?: ResponseStatus | undefined;
}

/** UserApiKey */
export class UserApiKey implements IUserApiKey {
    key?: string | undefined;
    keyType?: string | undefined;
    expiryDate?: Date | undefined;
    meta?: Dictionary_String_String_ | undefined;

    constructor(data?: IUserApiKey) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any, _mappings?: any) {
        if (_data) {
            this.key = _data["Key"];
            this.keyType = _data["KeyType"];
            this.expiryDate = _data["ExpiryDate"] ? new Date(_data["ExpiryDate"].toString()) : <any>undefined;
            this.meta = _data["Meta"] ? Dictionary_String_String_.fromJS(_data["Meta"], _mappings) : <any>undefined;
        }
    }

    static fromJS(data: any, _mappings?: any): UserApiKey {
        data = typeof data === 'object' ? data : {};
        return createInstance<UserApiKey>(data, _mappings, UserApiKey);
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Key"] = this.key;
        data["KeyType"] = this.keyType;
        data["ExpiryDate"] = this.expiryDate ? this.expiryDate.toISOString() : <any>undefined;
        data["Meta"] = this.meta ? this.meta.toJSON() : <any>undefined;
        return data;
    }
}

/** UserApiKey */
export interface IUserApiKey {
    key?: string | undefined;
    keyType?: string | undefined;
    expiryDate?: Date | undefined;
    meta?: Dictionary_String_String_ | undefined;
}

/** Accept Header */
export enum Accept {
    Application_json = "application/json",
}

function jsonParse(json: any, reviver?: any) {
    json = JSON.parse(json, reviver);

    var byid: any = {};
    var refs: any = [];
    json = (function recurse(obj: any, prop?: any, parent?: any) {
        if (typeof obj !== 'object' || !obj)
            return obj;

        if ("$ref" in obj) {
            let ref = obj.$ref;
            if (ref in byid)
                return byid[ref];
            refs.push([parent, prop, ref]);
            return undefined;
        } else if ("$id" in obj) {
            let id = obj.$id;
            delete obj.$id;
            if ("$values" in obj)
                obj = obj.$values;
            byid[id] = obj;
        }

        if (Array.isArray(obj)) {
            obj = obj.map((v, i) => recurse(v, i, obj));
        } else {
            for (var p in obj) {
                if (obj.hasOwnProperty(p) && obj[p] && typeof obj[p] === 'object')
                    obj[p] = recurse(obj[p], p, obj);
            }
        }

        return obj;
    })(json);

    for (let i = 0; i < refs.length; i++) {
        const ref = refs[i];
        ref[0][ref[1]] = byid[ref[2]];
    }

    return json;
}

function createInstance<T>(data: any, mappings: any, type: any): T {
    if (!mappings)
        mappings = [];
    else {
        let mapping = mappings.filter((m: any) => m.source === data);
        if (mapping.length === 1)
            return <T>mapping[0].target;
    }

    let result: any = new type();
    mappings.push({ source: data, target: result });
    result.init(data, mappings);
    return result;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}
